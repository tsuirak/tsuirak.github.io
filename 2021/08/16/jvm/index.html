

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#6f7b5b">
  <meta name="description" content="">
  <meta name="author" content="tsuiraku">
  <meta name="keywords" content="">
  
  <title>JVM - tsuiraku</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":100,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"dC2NdQqyqOkPy2Xg2ij7PMS4-gzGzoHsz","app_key":"XMhtIUKKmpfGkgkdObosNu5I","server_url":"https://dc2ndqqy.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>tsuiraku</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-16 22:57" pubdate>
        2021年8月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      115
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM</h1>
            
            <div class="markdown-body">
              <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>$\textcolor{OliveGreen}{一次编写，到处运行}$</li>
<li>$\textcolor{OliveGreen}{自动内存管理，垃圾回收机制}$</li>
<li>$\textcolor{OliveGreen}{数组下标越界检查}$</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>JVM JRE JDK的区别</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><h4 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h4><p>$\textcolor{OliveGreen}{用于保存jvm中下一条所要执行的指令的地址}$</p>
<h4 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h4><ul>
<li>$\textcolor{OliveGreen}{线程私有}$<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>$\textcolor{OliveGreen}{不会存在内存溢出}$</li>
</ul>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><ul>
<li>-Xss</li>
</ul>
<h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		method1();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>		method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> c = a + b;<br>		<span class="hljs-keyword">return</span> c;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p>
<h5 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h5><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h4 id="2-2-内存溢出"><a href="#2-2-内存溢出" class="headerlink" title="2.2 内存溢出"></a>2.2 内存溢出</h4><p><code>Java.lang.stackOverflowError</code> 栈内存溢出</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ul>
<li>$\textcolor{OliveGreen}{虚拟机栈中，栈帧过多（无限递归）}$</li>
<li>$\textcolor{OliveGreen}{每个栈帧所占用过大}$</li>
</ul>
<h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul>
<li><code>top</code>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><code>ps H -eo pid, tid, %cpu | grep + 进程id</code>  通过 <code>ps</code>命令进一步查看是哪个<strong>线程</strong>占用CPU过高</li>
<li><code>jstack + 进程id</code> 通过查看进程中的线程的<code>tid</code>，通过<code>ps</code>命令查看的<code>tid</code>来<strong>对比定位</strong>，注意<code>jstack</code>查找出的线程<code>tid</code>是<strong>16进制的</strong>，<strong>需要转换</strong></li>
</ul>
</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p>一些带有<code>native</code><strong>关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h3><ul>
<li>-Xmx</li>
</ul>
<h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>$\textcolor{OliveGreen}{所有线程共享，堆内存中的对象都需要考虑线程安全问题}$</li>
<li>$ \textcolor{OliveGreen}{有垃圾回收机制}$</li>
</ul>
<h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><p><code>java.lang.OutofMemoryError: Java heap space </code> 堆内存溢出</p>
<h4 id="4-3-堆内存诊断工具"><a href="#4-3-堆内存诊断工具" class="headerlink" title="4.3 堆内存诊断工具"></a>4.3 堆内存诊断工具</h4><ul>
<li><p><code>jps</code></p>
<ul>
<li>查看当前系统中有哪些java进程</li>
</ul>
</li>
<li><p><code>jmap</code></p>
<ul>
<li>查看堆内存占用情况（某一时刻）</li>
</ul>
</li>
<li><p><code>jconsole</code></p>
<ul>
<li>图形化界面，多功能的监测工具，可以连续监测</li>
</ul>
</li>
<li><p><code>jvirsalvm</code></p>
</li>
</ul>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h3><h4 id="5-1-结构"><a href="#5-1-结构" class="headerlink" title="5.1 结构"></a>5.1 结构</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h4 id="5-2-内存溢出"><a href="#5-2-内存溢出" class="headerlink" title="5.2 内存溢出"></a>5.2 内存溢出</h4><ul>
<li>1.8以前会导致<strong>永久代</strong>内存溢出 <ul>
<li><code>-XX:MaxPermSize=8m</code></li>
<li><code>java.lang.OutOfMemoryError: PermGen space</code></li>
</ul>
</li>
<li>1.8以后会导致<strong>元空间</strong>内存溢出<ul>
<li>元空间使用系统内存</li>
<li><code> -XX:MaxMetaspaceSize=8m</code></li>
<li><code>java.lang.OutOfMemoryError: Metaspace</code></li>
</ul>
</li>
</ul>
<h4 id="5-3-运行时常量池"><a href="#5-3-运行时常量池" class="headerlink" title="5.3 运行时常量池"></a>5.3 运行时常量池</h4><ul>
<li><p>二进制字节码的组成</p>
<ul>
<li>类的基本信息</li>
<li>常量池</li>
<li>类的方法定义（包含了虚拟机指令）</li>
</ul>
</li>
<li><p>通过反编译来查看类的信息</p>
<ul>
<li><p>获得对应类的.class文件</p>
</li>
<li><p>在控制台输入 javap -v 类的路径</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">javap -v xxx.<span class="hljs-built_in">class</span><br></code></pre></td></tr></table></figure></li>
<li><p>在控制台看到反编译以后类的信息了</p>
<ul>
<li><p>类的基本信息</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>常量池</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
<li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="常量池与运行时常量池的区别"><a href="#常量池与运行时常量池的区别" class="headerlink" title="常量池与运行时常量池的区别"></a>常量池与运行时常量池的区别</h5><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li>
</ul>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="5-4-常量池与串池的关系"><a href="#5-4-常量池与串池的关系" class="headerlink" title="5.4 常量池与串池的关系"></a>5.4 常量池与串池的关系</h4><h4 id="5-5-串池-String-space-Table"><a href="#5-5-串池-String-space-Table" class="headerlink" title="5.5 串池 $String\space Table$"></a>5.5 <strong>串池</strong> $String\space Table$</h4><ul>
<li>特征<ul>
<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是 <strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
<li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li>
<li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li>
</ul>
</li>
</ul>
<p>用来放字符串对象且里面的<strong>元素不重复</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String a = <span class="hljs-string">&quot;a&quot;</span>; <br>		String b = <span class="hljs-string">&quot;b&quot;</span>;<br>		String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String a</span><br><span class="hljs-attr">2:</span> <span class="hljs-string">astore_1</span><br><span class="hljs-attr">3:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#3                  // String b</span><br><span class="hljs-attr">5:</span> <span class="hljs-string">astore_2</span><br><span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String ab</span><br><span class="hljs-attr">8:</span> <span class="hljs-string">astore_3</span><br><span class="hljs-attr">9:</span> <span class="hljs-string">returnCopy</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
</li>
<li><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
</li>
<li><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
</li>
</ul>
<p>最终 <strong>StringTable [“a”, “b”, “ab”]</strong></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String a = <span class="hljs-string">&quot;a&quot;</span>;<br>		String b = <span class="hljs-string">&quot;b&quot;</span>;<br>		String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-comment">// 拼接字符串对象来创建新的字符串</span><br>		String ab2 = a+b; <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs console">Code:<br>  stack=2, locals=6, args_size=1<br>     0: ldc           #2         // String a<br>     2: astore_1<br>     3: ldc           #3         // String b<br>     5: astore_2<br>     6: ldc           #4         // String ab<br>     8: astore_3<br>     9: new           #5         // class java/lang/StringBuilder<br>    12: dup<br>    13: invokespecial #6         // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V<br>    16: aload_1<br>    17: invokevirtual #7         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br>    20: aload_2<br>    21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br>    24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br>    27: astore        4<br>    //ab3初始化时直接从串池中获取字符串<br>    29: ldc           #4                  // String ab<br>    31: astore        5<br>    33: return<br></code></pre></td></tr></table></figure>

<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>new StringBuilder().append(“a”).append(“b”).toString()</code></p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>String ab2 = a+b;<br><span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br>System.out.println(ab == ab2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>



<p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		String a = <span class="hljs-string">&quot;a&quot;</span>;<br>		String b = <span class="hljs-string">&quot;b&quot;</span>;<br>		String ab = <span class="hljs-string">&quot;ab&quot;</span>;<br>		String ab2 = a+b;<br>		<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span><br>		String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>    <br>    System.out.println(ab == ab3); <span class="hljs-comment">// true</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Code:</span><br>  <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=6,</span> <span class="hljs-string">args_size=1</span><br>     <span class="hljs-attr">0:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#2                  // String a</span><br>     <span class="hljs-attr">2:</span> <span class="hljs-string">astore_1</span><br>     <span class="hljs-attr">3:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#3                  // String b</span><br>     <span class="hljs-attr">5:</span> <span class="hljs-string">astore_2</span><br>     <span class="hljs-attr">6:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String ab</span><br>     <span class="hljs-attr">8:</span> <span class="hljs-string">astore_3</span><br>     <span class="hljs-attr">9:</span> <span class="hljs-string">new</span>           <span class="hljs-comment">#5                  // class java/lang/StringBuilder</span><br>    <span class="hljs-attr">12:</span> <span class="hljs-string">dup</span><br>    <span class="hljs-attr">13:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>    <span class="hljs-attr">16:</span> <span class="hljs-string">aload_1</span><br>    <span class="hljs-attr">17:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>    <span class="hljs-attr">20:</span> <span class="hljs-string">aload_2</span><br>    <span class="hljs-attr">21:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>    <span class="hljs-attr">24:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>    <span class="hljs-attr">27:</span> <span class="hljs-string">astore</span>        <span class="hljs-number">4</span><br>    <span class="hljs-string">//ab3初始化时直接从串池中获取字符串</span><br>    <span class="hljs-attr">29:</span> <span class="hljs-string">ldc</span>           <span class="hljs-comment">#4                  // String ab</span><br>    <span class="hljs-attr">31:</span> <span class="hljs-string">astore</span>        <span class="hljs-number">5</span><br>    <span class="hljs-attr">33:</span> <span class="hljs-string">returnCopy</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</p>
</li>
<li><p>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></p>
</li>
</ul>
<h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p><strong>例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 串池：&quot;a&quot; &quot;b&quot; </span><br>    <span class="hljs-comment">// 堆：str new StringBuild.append(&quot;a&quot;).appned(&quot;b&quot;).toStirng()</span><br>    <span class="hljs-comment">// 堆：new String(&quot;a&quot;) </span><br>    <span class="hljs-comment">// 堆：new String(&quot;b&quot;) </span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>		<br>    <span class="hljs-comment">// 调用str的intern方法，此时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br>   	<span class="hljs-comment">// 将&quot;ab&quot;对象返回给str2</span><br>		String str2 = str.intern();<br>		<br>    <span class="hljs-comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<br>    <span class="hljs-comment">// 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br>		System.out.println(str == st2); <span class="hljs-comment">// true</span><br>		System.out.println(str == str3); <span class="hljs-comment">// true</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    <br>    <span class="hljs-comment">// 串池：&quot;a&quot; &quot;b&quot; 被放入串池中</span><br>    <span class="hljs-comment">// 堆：str</span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>   <br>    <span class="hljs-comment">// 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br>		String str2 = str.intern();<br>     <br>    <span class="hljs-comment">// 堆中与串池中&quot;ab&quot;不一样</span><br>		System.out.println(str == str2);  <span class="hljs-comment">// false</span><br>		System.out.println(str == str3); <span class="hljs-comment">// false</span><br>		System.out.println(str2 == str3);  <span class="hljs-comment">// true</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象<strong>复制</strong>一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<p><strong>例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 串池：&quot;a&quot; &quot;b&quot; </span><br>    <span class="hljs-comment">// 堆：str new StringBuild.append(&quot;a&quot;).appned(&quot;b&quot;).toStirng()</span><br>    <span class="hljs-comment">// 堆：new String(&quot;a&quot;) </span><br>    <span class="hljs-comment">// 堆：new String(&quot;b&quot;) </span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>		<br>    <span class="hljs-comment">// 调用str的intern方法，此时串池中没有&quot;ab&quot;，则会将该字符串对象复制一份放入到串池中，此时堆内存与串池中的&quot;ab&quot;不是是同一个对象</span><br>    <span class="hljs-comment">// 串池：str2</span><br>		String str2 = str.intern();<br>		<br>    <span class="hljs-comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br>    <span class="hljs-comment">// 串池：str3</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>		<br>    <span class="hljs-comment">// 堆内存并不是与串池&quot;ab为同一个对象</span><br>		System.out.println(str == st2); <span class="hljs-comment">// false</span><br>		System.out.println(str == str3); <span class="hljs-comment">// false</span><br>    System.out.println(str2 == str3); <span class="hljs-comment">// true</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br>		String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    <br>    <span class="hljs-comment">// 串池：&quot;a&quot; &quot;b&quot; 被放入串池中</span><br>    <span class="hljs-comment">// 堆：str</span><br>		String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>   <br>    <span class="hljs-comment">// 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，返回串池中的&quot;ab&quot;</span><br>		String str2 = str.intern();<br>     <br>    <span class="hljs-comment">// 堆中与串池中&quot;ab&quot;不一样</span><br>		System.out.println(str == str2);  <span class="hljs-comment">// false</span><br>		System.out.println(str == str3); <span class="hljs-comment">// false</span><br>		System.out.println(str2 == str3);  <span class="hljs-comment">// true</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// jvm1.8</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 串池：s1 s2 s3 s5 s6</span><br>    <span class="hljs-comment">// 堆：s4</span><br>		String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>    String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>    String s4 = s1 + s2;<br>    String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br>    String s6 = s4.intern();<br>    <br>    System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br>    System.out.println(s3 == s5); <span class="hljs-comment">// true</span><br>    System.out.println(s3 == s6); <span class="hljs-comment">// true</span><br>    <br>    <span class="hljs-comment">// 串池：&quot;c&quot; &quot;d&quot; x1=&quot;cd&quot;</span><br>    <span class="hljs-comment">// 堆：x2=&quot;cd&quot;</span><br>    String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<br>    String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>    <span class="hljs-comment">// 串池中已经存在&quot;cd&quot;，放入失败</span><br>    x2.intern();<br>    <br>    System.out.println(x1 == x2); <span class="hljs-comment">// false</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置"></a>5.6 StringTable 位置</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收"></a>5.7 StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p>
<h4 id="5-8-StringTable-调优"><a href="#5-8-StringTable-调优" class="headerlink" title="5.8 StringTable 调优"></a>5.8 StringTable 调优</h4><ul>
<li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">-<span class="hljs-variable">XX</span>:<span class="hljs-variable">StringTableSize</span>=<span class="hljs-function"><span class="hljs-title">xxxx</span>(🪣个数)</span><br></code></pre></td></tr></table></figure></li>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以通过<strong>intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><ul>
<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><ul>
<li>IO</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" srcset="/img/loading.gif" lazyload></a></p>
<ul>
<li>DirectBuffer</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p>
<h4 id="释放原理-❓"><a href="#释放原理-❓" class="headerlink" title="释放原理 ❓"></a>释放原理 ❓</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过 <code>unsafe.freeMemory</code> 来手动释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过ByteBuffer申请1M的直接内存</span><br>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);Copy<br></code></pre></td></tr></table></figure>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p>allocateDirect的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>DirectByteBuffer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span><br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br></code></pre></td></tr></table></figure>

<p>对应对象的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>&#125;Copy<br></code></pre></td></tr></table></figure>

<h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011408931.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h4 id="1-2-可达性分析算法-❓"><a href="#1-2-可达性分析算法-❓" class="headerlink" title="1.2 可达性分析算法 ❓"></a>1.2 可达性分析算法 ❓</h4><ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为GC Root的对象<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="1-3-5种引用"><a href="#1-3-5种引用" class="headerlink" title="1.3 5种引用"></a>1.3 5种引用</h4><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011409990.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>​    只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<p>​    如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>
<h5 id="1-3-2-软引用"><a href="#1-3-2-软引用" class="headerlink" title="1.3.2 软引用"></a>1.3.2 软引用</h5><p>​    当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<p>​    如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</p>
<p>​    软引用的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>		<span class="hljs-comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>		List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br>	&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure>

<p>​    如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>​    如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>		<span class="hljs-comment">// 使用引用队列，用于移除引用为空的软引用对象</span><br>		ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br>		<span class="hljs-comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>		List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>		SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<br><br>		<span class="hljs-comment">// 遍历引用队列，如果有元素，则移除</span><br>		Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>		<span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-comment">// 引用队列不为空，则从集合中移除该元素</span><br>			list.remove(poll);<br>			<span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>			po ll = queue.poll();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="1-3-3-弱引用"><a href="#1-3-3-弱引用" class="headerlink" title="1.3.3 弱引用"></a>1.3.3 弱引用</h5><p>​    只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<p>​    如上图如果B对象不再引用A3对象，则A3对象会被回收</p>
<p>​    <strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<h5 id="1-3-4-虚引用"><a href="#1-3-4-虚引用" class="headerlink" title="1.3.4 虚引用"></a>1.3.4 虚引用</h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="1-3-5-终结器引用"><a href="#1-3-5-终结器引用" class="headerlink" title="1.3.5 终结器引用"></a>1.3.5 终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><h4 id="2-1-标记-清除"><a href="#2-1-标记-清除" class="headerlink" title="2.1 标记-清除"></a>2.1 标记-清除</h4><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011411252.png" srcset="/img/loading.gif" lazyload style="zoom:40%;" />

<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="2-2-标记-整理"><a href="#2-2-标记-整理" class="headerlink" title="2.2 标记-整理"></a>2.2 标记-整理</h4><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011411345.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h4><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011412754.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011414736.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011414861.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011414261.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<h3 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3.分代回收"></a>3.分代回收</h3><img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011415172.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h4 id="3-1-回收流程"><a href="#3-1-回收流程" class="headerlink" title="3.1 回收流程"></a>3.1 回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011415076.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011417085.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011417306.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011417526.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011417003.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011418090.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<h4 id="3-2-GC-分析"><a href="#3-2-GC-分析" class="headerlink" title="3.2 GC 分析"></a>3.2 GC 分析</h4><h5 id="3-2-1-GC相关参数"><a href="#3-2-1-GC相关参数" class="headerlink" title="3.2.1 GC相关参数"></a>3.2.1 GC相关参数</h5><table>
<thead>
<tr>
<th align="center">含义</th>
<th align="left">参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆初始大小</td>
<td align="left">-Xms</td>
</tr>
<tr>
<td align="center">堆最大大小</td>
<td align="left">-Xmx 或 -XX:MaxHeapSize=size</td>
</tr>
<tr>
<td align="center">新生代大小</td>
<td align="left">-Xmn 或 -XX:NewSize=size + -XX:MaxNewSize=size</td>
</tr>
<tr>
<td align="center">幸存区比例（动态）</td>
<td align="left">-XX:initialSurvivorRation=ratio 或 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td align="center">幸存区比例</td>
<td align="left">-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td align="center">晋升阈值</td>
<td align="left">-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td align="center">晋升详情</td>
<td align="left">-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td align="center">GC详情</td>
<td align="left">-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td align="center">FullGC前MinorGC</td>
<td align="left">-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<h5 id="3-2-2-大对象处理策略"><a href="#3-2-2-大对象处理策略" class="headerlink" title="3.2.2 大对象处理策略"></a>3.2.2 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<h5 id="3-2-3-线程内存溢出"><a href="#3-2-3-线程内存溢出" class="headerlink" title="3.2.3 线程内存溢出"></a>3.2.3 线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h4 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h4><ul>
<li>单线程</li>
<li>内存较小，个人电脑（CPU核数较少）</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011418507.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h5 id="4-1-1-Serial-收集器"><a href="#4-1-1-Serial-收集器" class="headerlink" title="4.1.1 Serial 收集器"></a>4.1.1 Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h5 id="4-1-2-ParNew-收集器"><a href="#4-1-2-ParNew-收集器" class="headerlink" title="4.1.2 ParNew 收集器"></a>4.1.2 ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h5 id="4-1-3-Serial-Old-收集器"><a href="#4-1-3-Serial-Old-收集器" class="headerlink" title="4.1.3 Serial Old 收集器"></a>4.1.3 Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p>
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
<h4 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li><strong>单位时间内</strong>，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用</strong>的垃圾回收器</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011418365.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-2-1-Parallel-Scavenge-收集器"><a href="#4-2-1-Parallel-Scavenge-收集器" class="headerlink" title="4.2.1 Parallel Scavenge 收集器"></a>4.2.1 Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h5 id="4-2-2-Parallel-Old-收集器"><a href="#4-2-2-Parallel-Old-收集器" class="headerlink" title="4.2.2 Parallel Old 收集器"></a>4.2.2 Parallel Old 收集器</h5><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
<h4 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011420094.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-3-1-CMS-收集器"><a href="#4-3-1-CMS-收集器" class="headerlink" title="4.3.1 CMS 收集器"></a>4.3.1 CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World 问题</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1"></a>4.4 G1</h4><p>Garbage First</p>
<p>JDK 9以后默认使用，而且<strong>替代了CMS 收集器</strong></p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011419253.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-4-1-适用场景"><a href="#4-4-1-适用场景" class="headerlink" title="4.4.1 适用场景"></a>4.4.1 适用场景</h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
<p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011419767.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-4-2-G1垃圾回收阶段"><a href="#4-4-2-G1垃圾回收阶段" class="headerlink" title="4.4.2 G1垃圾回收阶段"></a>4.4.2 G1垃圾回收阶段</h5><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h6 id="4-4-2-1-Young-Collection"><a href="#4-4-2-1-Young-Collection" class="headerlink" title="4.4.2.1 Young Collection"></a>4.4.2.1 Young Collection</h6><p><strong>分区算法region</strong></p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li>会STW</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011420416.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011421899.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011421653.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h6 id="4-4-2-2-Young-Collection-CM"><a href="#4-4-2-2-Young-Collection-CM" class="headerlink" title="4.4.2.2 Young Collection + CM"></a>4.4.2.2 Young Collection + CM</h6><p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011421182.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h6 id="4-2-2-3-Mixed-Collection"><a href="#4-2-2-3-Mixed-Collection" class="headerlink" title="4.2.2.3 Mixed Collection"></a>4.2.2.3 Mixed Collection</h6><p>会对 E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记</li>
<li><strong>拷贝</strong>存活</li>
</ul>
<p><code>-XX:MaxGCPauseMills:xxx</code> 用于指定最长的停顿时间</p>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011422556.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-4-3-Full-GC"><a href="#4-4-3-Full-GC" class="headerlink" title="4.4.3 Full GC"></a>4.4.3 Full GC</h5><p><strong>对比</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>SerialGC<br><span class="hljs-bullet">-- </span>新生代内存不足发生的垃圾收集 - minor gc<br><span class="hljs-bullet">-- </span>老年代内存不足发生的垃圾收集 - full gc<br><br><span class="hljs-bullet">- </span>ParallelGC<br><span class="hljs-bullet">-- </span>新生代内存不足发生的垃圾收集 - minor gc<br><span class="hljs-bullet">-- </span>老年代内存不足发生的垃圾收集 - full gc<br><br><span class="hljs-bullet">- </span>CMS<br><span class="hljs-bullet">-- </span>新生代内存不足发生的垃圾收集 - minor gc<br><span class="hljs-bullet">-- </span>老年代内存不足<br><br><span class="hljs-bullet">- </span>G1<br><span class="hljs-bullet">-- </span>新生代内存不足发生的垃圾收集 - minor gc<br><span class="hljs-bullet">-- </span>老年代内存不足<br></code></pre></td></tr></table></figure>

<p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h5 id="4-4-4-Young-Collection-跨代引用"><a href="#4-4-4-Young-Collection-跨代引用" class="headerlink" title="4.4.4 Young Collection 跨代引用"></a>4.4.4 Young Collection 跨代引用</h5><ul>
<li>新生代回收的跨代引用（老年代引用新生代）问题</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011422185.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul>
</li>
</ul>
</li>
<li>在引用变更时通过 post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011422519.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-4-5-Remark"><a href="#4-4-5-Remark" class="headerlink" title="4.4.5 Remark"></a>4.4.5 Remark</h5><p><strong>重新标记阶段</strong></p>
<p>在垃圾回收时，收集器处理对象的过程中</p>
<ul>
<li>黑色：已被处理，需要保留的 </li>
<li>灰色：正在处理中的</li>
<li>白色：还未处理的</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011423927.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011423121.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-4-6-JDK-8u20-字符串去重"><a href="#4-4-6-JDK-8u20-字符串去重" class="headerlink" title="4.4.6 JDK 8u20 字符串去重"></a>4.4.6 JDK 8u20 字符串去重</h5><p>默认开启 <code>-XX:+UseStringDeduplication</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span><br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span><br></code></pre></td></tr></table></figure>

<p>过程</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与 String.intern 的区别<ul>
<li>intern关注的是字符串对象，StringTable(串池)</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="4-4-7-JDK-8u40-并发标记类卸载"><a href="#4-4-7-JDK-8u40-并发标记类卸载" class="headerlink" title="4.4.7 JDK 8u40 并发标记类卸载"></a>4.4.7 JDK 8u40 并发标记类卸载</h5><p>默认开启 <code>-XX:+ClassUnloadingWithConcurrentMark</code></p>
<p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h5 id="4-4-8-JDK-8u60-回收巨型对象"><a href="#4-4-8-JDK-8u60-回收巨型对象" class="headerlink" title="4.4.8 JDK 8u60 回收巨型对象"></a>4.4.8 JDK 8u60 回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<img src="https://tsuiraku.oss-cn-chengdu.aliyuncs.com/typora/202207011423889.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<h5 id="4-4-9-JDK-9并发标记起始时间的调整"><a href="#4-4-9-JDK-9并发标记起始时间的调整" class="headerlink" title="4.4.9 JDK 9并发标记起始时间的调整"></a>4.4.9 JDK 9并发标记起始时间的调整</h5><ul>
<li>并发标记必须在对堆空间占满前完成，否则退化为FULLGC</li>
</ul>
<h3 id="5-GC-调优"><a href="#5-GC-调优" class="headerlink" title="5.GC 调优"></a>5.GC 调优</h3><p>查看虚拟机参数命令</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">JAVA<span class="hljs-regexp">/JDK8.0/</span>bin/java -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure>

<p>可以根据参数去查询具体的信息</p>
<h4 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h4><p>低延迟 or 高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC（低延迟）</li>
<li>ParallelGC（高吞吐量）</li>
<li>Zing（低延迟）</li>
</ul>
<h4 id="5-3-最快的GC是不发生GC"><a href="#5-3-最快的GC是不发生GC" class="headerlink" title="5.3 最快的GC是不发生GC"></a>5.3 最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>加载的内存数据太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
</li>
</ul>
<h4 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优"></a>5.4 新生代调优</h4><ul>
<li>新生代的特点<ul>
<li>所有的 new 操作分配内存都是非常廉价的<ul>
<li>TLAB（thread-local allocation buffer）</li>
</ul>
</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于 Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<code>-Xmn</code><ul>
<li>不是</li>
<li>存在的问题<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
<li>Oracle：$25%heap\space size\lt generation\lt 50%heap\space size $</li>
</ul>
</li>
<li>新生代内存设置为能容纳 <code>[并发量*(请求-响应)]</code> 的数据为宜</li>
</ul>
</li>
</ul>
<h4 id="5-5-幸存区调优"><a href="#5-5-幸存区调优" class="headerlink" title="5.5 幸存区调优"></a>5.5 幸存区调优</h4><ul>
<li>幸存区需要能够保存 <code>当前活跃对象+需要晋升的对象</code></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升<ul>
<li><code>-XX:MaxTenuringThreshold=threshold</code></li>
<li>希望让生命周期短的对象通过 minor gc 回收，而不是晋升至老年代</li>
</ul>
</li>
</ul>
<h4 id="5-6-老年代调优"><a href="#5-6-老年代调优" class="headerlink" title="5.6 老年代调优"></a>5.6 老年代调优</h4><p>以 CMS 为例</p>
<ul>
<li>CMS的老年代内存越大越好</li>
<li>老年代调优之前先尝试不进行调优<ul>
<li>等待一段时间，若没有发生 FULL GC，说明老年代的内存已经足够大，尝试先调试新生代</li>
</ul>
</li>
<li>观察发生 FULL GC的老年代内存占用，讲老年代内存预设调大 $\frac{1}{4} \sim \frac{1}{3}$<ul>
<li><code>-XX:CMSInitaiatingOccupancyFraction=percent</code></li>
</ul>
</li>
</ul>
<h4 id="5-7-GC调优的案例"><a href="#5-7-GC调优的案例" class="headerlink" title="5.7 GC调优的案例"></a>5.7 GC调优的案例</h4><ul>
<li>案例1，FULL GC 和 Minor GC 频繁<ul>
<li>增大新生代的内存</li>
</ul>
</li>
<li>案例2，请求高峰期发生 FULL GC，单次暂停时间特别长（CMS）<ul>
<li>业务需要低延迟，单次暂停时间特别长</li>
<li>发现是重新标记阶段时间过长，在重新标记之前对新生代做垃圾清理 <code>-XX:+CMSScavengeBeforeRemark</code></li>
</ul>
</li>
<li>案例3，老年代充裕情况下，发生 FULL GC（JDK1.7）<ul>
<li>方法区采用永久代（非元空间），永久代的空间不足</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/Java%E8%AF%AD%E8%A8%80/">Java语言</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/Java%E8%AF%AD%E8%A8%80/JVM/">JVM</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处： <a target="_blank" href="https://tsuiraku.com/" rel="nofollow noopener noopener">tsuiraku</a>
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/17/spring/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/10/springboot-springcache+redis/">
                        <span class="hidden-mobile">springboot整合：springcache & redis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"dC2NdQqyqOkPy2Xg2ij7PMS4-gzGzoHsz","appKey":"XMhtIUKKmpfGkgkdObosNu5I","placeholder":"优质评论可以帮助作者获得更高权重（可以填写您的昵称以及联系方式，方便作者回复）","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->



    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
<div>
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("10/01/2021 8:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站已经运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  </script>
</div>

  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script>
  <link defer rel="stylesheet" href="/css/backgroundize.css" />
  
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?tsuirak";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="tsuirak";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
