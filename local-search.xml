<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/10/10/computer-network/"/>
    <url>/2020/10/10/computer-network/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>编程基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2020/10/10/java-collection/"/>
    <url>/2020/10/10/java-collection/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java异常</title>
    <link href="/2020/10/10/java-exception/"/>
    <url>/2020/10/10/java-exception/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>异常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机</title>
    <link href="/2020/10/10/java-jvm/"/>
    <url>/2020/10/10/java-jvm/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java反射</title>
    <link href="/2020/10/10/java-reflection/"/>
    <url>/2020/10/10/java-reflection/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2020/10/10/java-socket/"/>
    <url>/2020/10/10/java-socket/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2020/10/10/nginx/"/>
    <url>/2020/10/10/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><em><strong>Nginx</strong></em> 是高性能的 <em><strong>HTTP</strong></em> 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验，有报告表明能支持高达 50,000 个并发连接数。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><strong>正向代理</strong></p><p><em><strong>Nginx</strong></em> 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 <em><strong>Internet</strong></em> 想象成一个巨大的资源库，则局域网中的客户端要访问 <em><strong>Internet</strong></em>，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p><p><u>需要在客户端配置代理服务器进行指定网站访问</u>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.29.54.png" style="zoom:50%;" /><p><strong>反向代理</strong></p><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，<u>暴露的是代理服务器地址，隐藏了真实服务器 <em><strong>IP</strong></em> 地址</u>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.35.09.png" style="zoom:50%;" /><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>单一模式</strong></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.40.11.png" style="zoom:50%;" /><p><strong>负载均衡</strong></p><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.45.55.png" style="zoom:50%;" /><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.49.18.png" style="zoom:50%;" /><h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><p>官网：<a href="http://nginx.org/">http://nginx.org/</a></p><blockquote><ol><li>需要安装 <em><strong>gcc-c++</strong></em> 编译器</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> gcc-c++<br>yum <span class="hljs-keyword">install</span> -y openssl openssl-devel<br></code></pre></td></tr></table></figure><ol start="2"><li>安装 <em><strong>pcre</strong></em> 包</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y pcre pcre-devel<br></code></pre></td></tr></table></figure><ol start="3"><li>安装 <em><strong>zlib</strong></em> 包</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">yum install -y <span class="hljs-literal">zlib</span> <span class="hljs-literal">zlib</span>-devel<br></code></pre></td></tr></table></figure><ol start="4"><li>在 <em><strong>/opt/</strong></em>  下载 <em><strong>nginx</strong></em></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://nginx.org/download/nginx-1.19.9.tar.gz<br></code></pre></td></tr></table></figure><ol start="5"><li>解压并进入 <em><strong>nginx</strong></em> 目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf nginx-1.19.9.tar.gz<br><span class="hljs-built_in">cd</span> nginx-1.19.9<br></code></pre></td></tr></table></figure><ol start="6"><li>使用 <em><strong>nginx</strong></em> 默认配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure<br></code></pre></td></tr></table></figure><ol start="7"><li>编译安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>默认安装路径：<code>/usr/local/nginx</code></p><p>启动：<code>cd /usr/local/nginx/sbin</code></p><p>默认启动脚本：<code>./nginx</code></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 17.02.59.png" style="zoom:50%;" /><p>成功启动后可以进行访问：<code>172.16.88.168:80</code>（需要关闭防火墙）</p><p>默认端口：80</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/nginx/sbin <span class="hljs-comment"># 默认安装路径</span><br><br>./nginx -v <span class="hljs-comment"># 查看 nginx 版本号 </span><br><br>./nginx <span class="hljs-comment"># 启动 nginx</span><br><br>./nginx -s stop <span class="hljs-comment"># 停止 nginx </span><br><br>./nginx -s reload <span class="hljs-comment"># 重新加载 nginx </span><br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><em><strong>nginx.conf</strong></em></p><p>默认路径：***/usr/local/nginx/conf/nginx.conf***</p><blockquote><p><em><strong>全局块</strong></em></p><p>主要包括配置运行 <em><strong>Nginx</strong></em> 服务器的用户（组）、允许生成的 <em><strong>worker process</strong></em> 数，进程 <em><strong>PID</strong></em> 存放路径、日志存放路径和类型以及配置文件的引入等。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 21.47.03.png" style="zoom:50%;" /><p><em><strong>events块</strong></em></p><p><em><strong>events</strong></em> 块涉及的指令主要影响 <em><strong>Nginx</strong></em> 服务器与用户的网络连接，常用的设置包括是否开启对多 <em><strong>work process</strong></em> 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 <em><strong>word process</strong></em> 可以同时支持的最大连接数等。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 21.48.11.png" style="zoom:50%;" /><p><em><strong>http块</strong></em></p><p>这算是 <em><strong>Nginx</strong></em> 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：<em><strong>http</strong></em> 块也可以包括 <em><strong>http</strong></em> 全局块、<em><strong>server</strong></em> 块。</p><ol><li><p><em><strong>http 全局块</strong></em></p><p><em><strong>http</strong></em> 全局块配置的指令包括文件引入、<em><strong>MIME-TYPE</strong></em> 定义、日志自定义、连接超时时间、单链接请求数上限等。</p></li><li><p><em><strong>server块</strong></em></p><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。</p><p>每个 <em><strong>http</strong></em> 块可以包括多个 <em><strong>server</strong></em> 块，而每个 <em><strong>server</strong></em> 块就相当于一个虚拟主机。 而每个 <em><strong>server</strong></em> 块也分为全局 <em><strong>server</strong></em> 块，以及可以同时包含多个 <em><strong>locaton</strong></em> 块。</p><ol><li><p><em><strong>全局 server 块</strong></em></p><p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p></li><li><p><em><strong>location 块</strong></em></p><p>一个 <em><strong>server</strong></em> 块可以配置多个 <em><strong>location</strong></em> 块。</p><p>这块的主要作用是基于 <em><strong>Nginx</strong></em> 服务器接收到的请求字符串（例如 <em><strong>server_name/uri-string</strong></em>），对虚拟主机名称（也可以是 <em><strong>IP</strong></em> 别名）之外的字符串（例如 前面的 <em><strong>/uri-string</strong></em>）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ol></li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 21.48.47.png" style="zoom:50%;" /></blockquote><h2 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h2><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">实现效果：使用 nginx 进行反向代理，访问 www<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.com</span> 直接跳转到 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>访问的流程：</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 23.55.12.png" alt="" style="zoom:50%;" /><p>如何启动 <em><strong>tomcat</strong></em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> tomcat安装路径bin目录<span class="hljs-regexp">//</span> 默认端口<span class="hljs-number">8080</span>./startup.sh<br></code></pre></td></tr></table></figure><ol><li>本地 <em><strong>hosts</strong></em> 文件进行域名和 <em><strong>ip</strong></em> 对应配置</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 最后一行加上# 虚拟机对应的ip172<span class="hljs-number">.16</span><span class="hljs-number">.88</span><span class="hljs-number">.168</span> www.test.com<br></code></pre></td></tr></table></figure><ol start="2"><li>在 <em><strong>nginx</strong></em> 进行请求转发的配置（反向代理配置）</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 23.54.20.png" alt="" style="zoom:50%;" /><ol start="3"><li>启动 <em><strong>nginx</strong></em></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 默认路径 <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/./</span>nginx -c <span class="hljs-regexp">/opt/</span>etc/nginx.conf <span class="hljs-comment"># 配置文件的路径</span><br></code></pre></td></tr></table></figure><p>最终：访问 <code>wwww.test.com</code> 跳转到 <em><strong>tomcat</strong></em> 成功启动页面。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 23.56.21.png" style="zoom:50%;" /><hr><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 <span class="hljs-number">9001</span>访问 http:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>:<span class="hljs-number">9001</span><span class="hljs-regexp">/edu/</span> 直接跳转到 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>访问 http:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>:<span class="hljs-number">9001</span><span class="hljs-regexp">/vod/</span> 直接跳转到 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><ol><li><p>准备两个 <em><strong>tomcat</strong></em> 服务器（略）</p></li><li><p>配置 <em><strong>nginx.conf</strong></em></p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;        listen       <span class="hljs-number">9001</span>;        server_name  <span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>;        location ~ <span class="hljs-regexp">/edu/</span> &#123;            proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>;        &#125;        location ~ <span class="hljs-regexp">/vod/</span> &#123;            proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span>;        &#125; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><em>proxy_pass</em></h3><blockquote><p>格式： <em><strong>proxy_pass URL</strong></em></p><p>URL包含：传输协议、主机名、<em><strong>uri</strong></em></p></blockquote><p><em><strong>url</strong></em> 的 / 问题</p><blockquote><p>在 <em><strong>nginx</strong></em> 中配置 <em><strong>proxy_pass</strong></em> 时，当在后面的 <em><strong>url</strong></em> 加上了/，相当于是绝对根路径，则 <em><strong>nginx</strong></em> 不会把 <em><strong>location</strong></em> 中匹配的路径部分代理；</p><p>如果没有 /，则会把匹配的路径部分也给代理。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">假设 server_name:192.168.1.10请求:http://192.168.1.10/a/a.html示例1：location /a/&#123;    proxy_pass http://192.168.1.10;    ...&#125;结果1：http://192.168.1.10/a/a.html示例2：location /a/&#123;    proxy_pass http://192.168.1.10/;    ...&#125;结果2：http://192.168.1.10/a.html示例3：location /a/&#123;    proxy_pass http://192.168.1.10/nanase;    ...&#125;结果3：http://192.168.1.10/nanasea.html示例4：location /a/&#123;    proxy_pass http://192.168.1.10/nanase/;    ...&#125;结果4：http://192.168.1.10/nanase/a.html<br></code></pre></td></tr></table></figure><p><strong><u>为了方便记忆和规范配置，建议所有的 <em>proxy_pass</em> 后的 <em>url</em> 都以 / 结尾。</u></strong></p><h3 id="location"><a href="#location" class="headerlink" title="location"></a><em>location</em></h3><p>该指令用于匹配 <em><strong>URL</strong></em>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> [ = | <span class="hljs-regexp">~ |</span> <span class="hljs-regexp">~* |</span><span class="hljs-regexp"> ^~</span> ] uri &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>=</code> </p><p>用于不含正则表达式的 <em><strong>uri</strong></em> 前，要求请求字符串与 <em><strong>uri</strong></em> 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p><p><code>~</code></p><p>用于表示 <em><strong>uri</strong></em> 包含正则表达式，并且区分大小写。</p><p><code>~*</code></p><p>用于表示 <em><strong>uri</strong></em> 包含正则表达式，并且不区分大小写。</p><p><code>^~</code></p><p>用于不含正则表达式的 <em><strong>uri</strong></em> ，要求 <em><strong>Nginx</strong></em> 服务器找到标识 <em><strong>uri</strong></em> 和请求 符串匹配度最高的 <em><strong>location</strong></em> 后，立即使用此 <em><strong>location</strong></em> 处理请求，而不再使用 <em><strong>location</strong></em> 块中的正则 <em><strong>uri</strong></em> 和请求字符串做匹配。</p></blockquote><p><strong><u><em>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</em></u></strong>                 </p><p>​                                                                       </p><h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上面。即将原先请求集中到单个服务器上转化为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p><h4 id="案例-1-1"><a href="#案例-1-1" class="headerlink" title="案例 1"></a>案例 1</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">实现效果：浏览器地址栏输入地址 http:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span><span class="hljs-regexp">/edu/</span>a.html，负载均衡效果，平均分担 <span class="hljs-number">8080</span> 和 <span class="hljs-number">8081</span> 端口中。<br></code></pre></td></tr></table></figure><ol><li>准备两个 <em><strong>tomcat</strong></em> 服务器（略）</li><li>配置 <em><strong>nginx.conf</strong></em> 文件</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span> &#123;...upsteam myserver &#123;ip_hash;server <span class="hljs-number">172.16.88.168:8080</span> weight=<span class="hljs-number">1</span>;server <span class="hljs-number">172.16.88.168:8081</span> weight=<span class="hljs-number">1</span>;&#125;server &#123;        listen       <span class="hljs-number">80</span>;        server_name  <span class="hljs-number">172.16.88.168</span>;        location / &#123;            proxy_pass http://myserver;            root html;            index index.html index.htm;        &#125; ... &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><ul><li><p><em><strong>轮询</strong></em>（默认）<br> 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 <em><strong>down</strong></em> 掉，能自动剔除。</p></li><li><p><em><strong>weight</strong></em><br> <em><strong>weight</strong></em> 代表权重默认为 1，权重越高被分配的客户端越多。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">upstream server_pool &#123;<span class="hljs-built_in">server </span>192.168.5.21 <span class="hljs-attribute">weight</span>=10; <span class="hljs-built_in">server </span>192.168.5.22 <span class="hljs-attribute">weight</span>=10; &#125;<br></code></pre></td></tr></table></figure></li><li><p><em><strong>ip_hash</strong></em><br> 每个请求按访问 <em><strong>ip</strong></em> 的 <em><strong>hash</strong></em> 结果分配，这样每个访客固定访问一个后端服务器。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">upstream server_pool &#123;<span class="hljs-attribute">ip_hash;server 192.168.5.21</span>:80; <span class="hljs-attribute">server 192.168.5.22</span>:80; &#125;<br></code></pre></td></tr></table></figure></li><li><p><em><strong>fair</strong></em>（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">upstream</span> server_pool &#123; server <span class="hljs-number">192.168.5.21:80</span>; server <span class="hljs-number">192.168.5.22:80</span>; fair;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h2><p><em><strong>Nginx</strong></em> 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。</p><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。</p><p>另外一种方法就是动态跟静态文件混合在一起发布，通过 <em><strong>nginx</strong></em> 来分开。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.18.44.png" style="zoom:50%;" /><h4 id="案例-1-2"><a href="#案例-1-2" class="headerlink" title="案例 1"></a>案例 1</h4><ol><li>在 <em><strong>linux</strong></em> 系统中准备静态资源，用于进行访问</li><li>配置 <em><strong>nginx</strong></em> 文件</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">server &#123;        listen       <span class="hljs-number">80</span>;        server_name  <span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>;        location <span class="hljs-regexp">/html/</span> &#123;        root <span class="hljs-regexp">/data/</span>;        index index.html index.htm;        # 访问 <span class="hljs-regexp">/data/</span>html<span class="hljs-regexp">/.*html        &#125;        location /im</span>age<span class="hljs-regexp">/ &#123;        root /</span>data/;        autoindex on; # 列出文件目录        &#125; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.21.39.png" alt="截屏2021-10-27 14.21.39" style="zoom:50%;" /><p>即主服务器宕机，启动备用服务器。</p><h4 id="案例-1-3"><a href="#案例-1-3" class="headerlink" title="案例 1"></a>案例 1</h4><p><em><strong>keepalive + nginx</strong></em></p><p><strong>高可用集群（主从模式）</strong></p><ol><li><p>准备两台服务器</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">服务器ip：<span class="hljs-number">192.168.17.128</span><span class="hljs-number">192.168.17.131</span><br></code></pre></td></tr></table></figure></li><li><p>两台服务器安装 <em><strong>keepalive</strong></em> 和 <em><strong>nginx</strong></em> （略）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> keepalive-y<br></code></pre></td></tr></table></figure></li><li><p>完成高可用配置（主从模式）</p><p>在 <code>/usr/local/src/</code> 添加检测脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bashA=`ps -C nginx –no-header |wc -l` if [ $A -eq 0 ];then/usr/local/nginx/sbin/nginxsleep 2if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then        killall keepalived    fifi</span><br></code></pre></td></tr></table></figure><p>配置主服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主要修改 keepalive 配置文件# /etc/keepalived/keepalived.conf# 主和备服务器修改不同地方# 全局配置global_defs &#123;notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc&#125;notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129smtp_connect_timeout 30router_id LVS_DEVEL # 访问主机服务器名字&#125;# 脚本配置vrrp_script chk_http_port &#123; script &quot;/usr/local/src/nginx_check.sh&quot; # 脚本interval 2 # 检测脚本执行的间隔weight 2 # 设置当前服务器的权重&#125;# 虚拟ip配置vrrp_instance VI_1 &#123; state MASTER # 主服务器：MASTER 备份服务器：BACKUP interface ens33 # 网卡virtual_router_id 51 # 主备机的id必须相同priority 100 # 优先级；主机值较大，备份机值较小 advert_int 1 # 时间间隔检测# 权限authentication &#123; auth_type PASSauth_pass 1111 &#125;# 虚拟ipvirtual_ipaddress &#123;192.168.17.50 # VRRP H 虚拟地址&#125;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>启动 <em><strong>nginx</strong></em> 和 <em><strong>keepalived</strong></em> 服务</p></li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="master-amp-worker"><a href="#master-amp-worker" class="headerlink" title="master&amp;worker"></a>master&amp;worker</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.49.04.png" style="zoom:50%;" /><h2 id="worker如何工作"><a href="#worker如何工作" class="headerlink" title="worker如何工作"></a>worker如何工作</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.59.12.png" style="zoom:50%;" /><h2 id="一个master多个worker"><a href="#一个master多个worker" class="headerlink" title="一个master多个worker"></a>一个master多个worker</h2><ul><li>可以使用 <em><strong>nginx –s reload</strong></em> 热部署，利用 <em><strong>nginx</strong></em> 进行热部署操作；</li><li>每个 <em><strong>woker</strong></em> 是独立的进程，如果有其中的一个 <em><strong>woker</strong></em> 出现问题，其他 <em><strong>woker</strong></em> 独立的， 继续进行争抢，实现请求过程，不会造成服务中断。</li></ul><h2 id="worker的数量"><a href="#worker的数量" class="headerlink" title="worker的数量"></a>worker的数量</h2><p><em><strong>nginx</strong></em> 类似 <em><strong>redis</strong></em> 都采用 <em><strong>io</strong></em> 多路复用机制，每个 <em><strong>worker</strong></em> 都是一个独立的进程。</p><p>即 <em><strong>worker</strong></em> 数量和服务器的 <em><strong>cpu</strong></em> 数量相等最合适。</p><h2 id="连接数worker-connection"><a href="#连接数worker-connection" class="headerlink" title="连接数worker_connection"></a>连接数worker_connection</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">第一个：发送请求，占用了 woker 的几个连接数? 答案:<span class="hljs-number"> 2 </span>或者<span class="hljs-number"> 4 </span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">第二个：nginx 有一个 master，有 <span class="hljs-number">4</span> 个 woker，每个 woker 支持最大的连接数 <span class="hljs-number">1024</span>，支持的最大并发数是多少?worker支持的最大连接数：<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>普通的静态访问最大并发数是：worker_connections * worker_processes <span class="hljs-regexp">/ 21024 * 4 /</span> <span class="hljs-number">2</span>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是：worker_connections * worker_processes <span class="hljs-regexp">/ 41024 * 4 /</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1zJ411w7SV?from=search&seid=5693495616515059218&spm_id_from=333.337.0.0">尚硅谷-王老师</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>服务器软件</category>
      
      <category>Web服务器</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/10/10/os/"/>
    <url>/2020/10/10/os/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>编程基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2020/10/10/spring/"/>
    <url>/2020/10/10/spring/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>Spring家族</category>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2020/10/10/springboot/"/>
    <url>/2020/10/10/springboot/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>Spring家族</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2020/10/10/java-thread/"/>
    <url>/2020/10/10/java-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li><p>进程是运行的程序。进程是程序的一次执行过程。操作系统会为进程分配内存空间；</p></li><li><p>动态过程：有自身的产生、存在和存亡的过程。</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是由进程创建的，是进程的一个实体；</li><li>一个进程可以拥有多个线程。</li></ul><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>同一时刻，只允许执行一个线程。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>同一时刻，可以允许执行多个线程。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p class="note note-primary">重要</p><p>同一个时刻，多个任务交替执行。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 08.54.41.png" alt="截屏2021-09-16 08.54.41" style="zoom:50%;" /><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p class="note note-primary">重要</p><p>同一个时刻，多个任务同时执行。多核 CPU 可以实现并行。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 08.54.55.png" style="zoom:50%;" /><h1 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a><u>线程使用</u></h1><p class="note note-primary">重要</p><blockquote><p>创建线程的两种方法</p><ul><li>基础 Thread 类，重写 run 方法；</li><li>实现 Runnable 接口，重写 run 方法。</li></ul></blockquote><p><strong>Diagram关系</strong></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 09.08.04.png"  style="zoom:50%;" /><p><strong>案例1： 继承Thread</strong></p><ol><li><p>编程一个线程，该线程每隔1秒在控制台输出文字 “Hello”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建 Cat 对象当作线程使用</span><br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br>        <span class="hljs-comment">// 启动线程</span><br>        cat.start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *  1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span><br><span class="hljs-comment"> *  2. 重写 run 方法，写上自己的业务代码</span><br><span class="hljs-comment"> *  3. run Thread 类 实现了 Runnable 接口的 run 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重写 run 方法，写自己的逻辑业务</span><br>        <span class="hljs-comment">// 调用 start 方法，会执行一次 run 方法</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对上题进行改进，当输出100次 “Hello” 后，停止输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建 Cat 对象当作线程使用</span><br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br>        <span class="hljs-comment">// 启动线程</span><br>        cat.start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *  1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span><br><span class="hljs-comment"> *  2. 重写 run 方法，写上自己的业务代码</span><br><span class="hljs-comment"> *  3. run Thread 类 实现了 Runnable 接口的 run 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重写 run 方法，写自己的逻辑业务</span><br>        <span class="hljs-comment">// 调用 start 方法，会执行一次 run 方法</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            time++;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(time == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">break</span>;  <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>画出程序的执行图。</p></li></ol><ul><li>当主线程（main 线程）启动一个子线程 Thread-0，主线程不会阻塞，会继续执行，此时主线程和子线程交替进行；</li><li>主线程结束后，若子线程还在运行，整个进程并不会结束。</li></ul><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 09.37.42.png"  style="zoom:50%;" /><p><strong>案例2：实现Runnable</strong></p><blockquote><p>Java是单继承的；</p><p>通过实现 Runnable接口来创建线程。</p></blockquote><p>编程一个线程，该线程每隔1秒在控制台输出文字 “Hello”。当输出10次后，自动退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// 无法直接调用 start 方法</span><br>        <span class="hljs-comment">// 创建 Thread 对象，将 dog 对象放入 Thread</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(dog);<br>        thread.start();;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + ++count + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例3：多线程</strong></p><p>创建两个线程，一个线程每隔1秒输出 “Hello World”，10次后退出；另一个线程每隔1秒输出 “hi”，5次后退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tsuiraku.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Hello hello = <span class="hljs-keyword">new</span> Hello();<br>        Hi hi = <span class="hljs-keyword">new</span> Hi();<br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(hello);<br>        Thread thread2 = <span class="hljs-keyword">new</span> Thread(hi);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + (++count) + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hi&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + (++count) + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>案例4：多线程模拟售票系统</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tsuiraku.thread.demo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        SellTicket01 s1 = new SellTicket01();</span><br><span class="hljs-comment">//        SellTicket01 s2 = new SellTicket01();</span><br><span class="hljs-comment">//        SellTicket01 s3 = new SellTicket01();</span><br><span class="hljs-comment">//        s1.start();</span><br><span class="hljs-comment">//        s2.start();</span><br><span class="hljs-comment">//        s3.start();</span><br><br>        SellTicket02 s = <span class="hljs-keyword">new</span> SellTicket02();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(s);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 Thread 方式</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 休眠50ms</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>            + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 Runnable 方式</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 休眠50ms</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>                    + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：出现 ticketNum 值为负数的情况。因为三个线程同时访问修改 tiketNum。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 10.51.12.png"  style="zoom:50%;" /><p>如何解决？<a href="#Synchronized">Synchronized</a></p><p><u><strong>源码</strong></u></p><p><code>thread.start()</code></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 09.48.18.png"  style="zoom:50%;" /><p>**<u>start0</u>**：<code>start0</code> 是一个 native 方法，由 JVM 调用。<code>start()</code> 方法调用 <code>start0()</code> 方法后，该线程并不一定马上执行，只是讲线程变成了可运行状态。具体执行时间，由 CPU 统一调度。</p><p><strong>思考</strong></p><ul><li><p><code>thread.start()</code> 和 <code>thread.run()</code>；</p><p>如果直接执行 <code>thread.run()</code> 方法，那么实际上是主线程在执行，并不会真正启动一个线程，并且程序会阻塞。而使用 <code>thread.start()</code> 方法，主线程会开启一个子线程，程序并不会阻塞，而是主线程和子线程交替进行。</p></li></ul><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><blockquote><p>当线程完成任务后，自动退出；</p><p>通过使用变量来控制 run 方法退出的方式停止线程，即通知方式。</p></blockquote><p><strong>案例</strong></p><p>启动一个线程 t，要求在 main 线程中停止线程 t。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        T t = <span class="hljs-keyword">new</span> T();<br>        t.start();<br><br>        <span class="hljs-comment">// 希望 main 线程控制 t 线程的终止，即修改 loop</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>        <br>        t.setLoop(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> loop = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (loop) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;T运行中...&quot;</span>);;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoop</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loop)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loop = loop;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 11.07.12.png"  style="zoom:50%;" /><h1 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h1><blockquote><p>setName；// 设置线程名称</p><p>getName；// 获取线程名称</p><p>start；// 执行线程，JVM调用底层 start0</p><p>run；// 调用线程对象 run 方法</p><p>setPriority；// 设置线程优先级</p><p>getPriority；// 获取线程优先级</p><p>sleep；// 线程休眠</p><p>interrupt；// 线程中断，但并没有真正结束线程。一般用于中断正在休眠的线程。</p><p>yield；// 线程的礼让。让出 CPU，让其他线程执行，但礼让的时间不确定，所以也不一定会成功。</p><p>join。//线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程的所有任务。</p></blockquote><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>实际上并没有让线程停止运行。一般用于唤醒正在休眠的线程。</p><h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><ul><li>yield</li></ul><p>线程主动礼让 CPU。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 13.48.42.png"  style="zoom:50%;" /><ul><li>join</li></ul><p>主动放弃 CPU，让其他线程插队。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 15.36.56.png"  style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadMethodExercise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> T());<br>    <span class="hljs-comment">// 创建子线程 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>      System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + i);<br>      <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// 说明主线程输出了 5 次 hi</span><br>        t.start(); <span class="hljs-comment">// 启动子线程 输出 hello...</span><br>        t.join(); <span class="hljs-comment">// 立即将 t 子线程，插入到 main 线程，让 t 先执行 </span><br>      &#125;<br>        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//输出一次 hi, 让 main 线程也休眠 1s </span><br>    &#125;<br>  &#125; <br>&#125;<br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + (++count)); <br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace(); &#125;<br>      <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123; <br>        <span class="hljs-keyword">break</span>;<br>       &#125; <br>    &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><u><strong>源码</strong></u></p><p>优先级</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 11.18.02.png"  style="zoom:50%;" /><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>也称为工作线程。当线程的任务执行完或者通知方式结束。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>一般是为工作线程服务的，当所有的用户线程结束后，守护线程自动结束。常见的守护线程：垃圾回收机制。</p><p>如何将一个线程设置为守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        T t = <span class="hljs-keyword">new</span> T();<br>        t.setDaemon(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 设置守护线程</span><br>        t.start();<br><br>        <span class="hljs-comment">// 希望当 main 线程结束后，希望子线程 t 自动终止</span><br>      <span class="hljs-comment">// 将子线程设置为守护线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;T 运行中...&quot;</span>);;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p class="note note-primary">重要</p><h3 id="七状态转化"><a href="#七状态转化" class="headerlink" title="七状态转化"></a><u>七状态转化</u></h3><blockquote><p><strong>新建状态（New）</strong></p><p>当用 new 操作符创建一个线程后， 此时线程处在新建状态。 当一个线程处于新建状态时，线程中的任务代码还没开始运行。</p><p><strong>就绪状态（Runnable）</strong></p><p>也被称为“可执行状态”。一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的 <code>start()</code> 方法。当调用了线程对象的 <code>start()</code> 方法即启动了线程，此时线程就处于就绪状态。</p><p>处于就绪状态的线程并不一定立即运行 <code>run()</code> 方法，线程还必须同其他就绪线程竞争 CPU，只有获得 CPU 使用权才可以运行线程。比如在单核心 CPU 的计算机系统中，不可能同时运行多个线程，一个时刻只能有一个线程处于运行状态。对与多个处于就绪状态的线程是由 Java 运行时系统的线程调度程序（thread scheduler）来调度执行。</p><p>除了调用 <code>start()</code> 方法后让线程变成就绪状态，一个线程阻塞状态结束后也可以变成就绪状态，或者从运行状态变化到就绪状态。</p><p><strong>运行状态（Running）</strong></p><p>线程获取到 CPU 使用权进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。真正开始执行 <code>run()</code> 方法的内容。</p><p><strong>阻塞状态（Blocked）</strong></p><p>线程在获取锁失败时（因为锁被其它线程抢占），它会被加入锁的同步阻塞队列，然后线程进入阻塞状态（Blocked）。处于阻塞状态（Blocked）的线程放弃 CPU 使用权，暂时停止运行。待其它线程释放锁之后，阻塞状态（Blocked）的线程将在次参与锁的竞争，如果竞争锁成功，线程将进入就绪状态（Runnable）。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 进入阻塞状态等待进入同步代码块的锁# 离开活的锁<br></code></pre></td></tr></table></figure><p><strong>等待状态（WAITING）</strong></p><p>或者叫条件等待状态，当线程的运行条件不满足时，通过锁的条件等待机制（调用锁对象的 <code>wait()</code> 或显示锁条件对象的 <code>await()</code> 方法）让线程进入等待状态（WAITING）。处于等待状态的线程将不会被 CPU 执行，除非线程的运行条件得到满足后，其可被其他线程唤醒，进入阻塞状态（Blocked）。调用不带超时的 Thread.join()方法也会进入等待状态。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"># 进入等待状态<span class="hljs-selector-tag">o</span><span class="hljs-selector-class">.wait</span>(time)<span class="hljs-selector-tag">t</span><span class="hljs-selector-class">.join</span>()<span class="hljs-selector-tag">LockSupport</span><span class="hljs-selector-class">.park</span>()# 离开<span class="hljs-selector-tag">o</span><span class="hljs-selector-class">.notify</span>()<span class="hljs-selector-tag">o</span><span class="hljs-selector-class">.notifyAll</span>()<span class="hljs-selector-tag">LockSupport</span><span class="hljs-selector-class">.unpark</span>()<br></code></pre></td></tr></table></figure><p><strong>限时等待状态（TIMED_WAITING）</strong></p><p>限时等待是等待状态的一种特例，线程在等待时我们将设定等待超时时间，如超过了我们设定的等待时间，等待线程将自动唤醒进入阻塞状态（Blocked）或就绪状态（Runnable)）。在调用 <code>Thread.sleep()</code> 方法，带有超时设定的 <code>Object.wait()</code> 方法，带有超时设定的 <code>Thread.join()</code> 方法等，线程会进入限时等待状态（TIMED_WAITING）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 进入限时等待状态<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(time)o.wait(time)t.join(time)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LockSupport</span>.</span></span>park<span class="hljs-constructor">Nanos()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LockSupport</span>.</span></span>park<span class="hljs-constructor">Until()</span># 离开时间结束<br></code></pre></td></tr></table></figure><p><strong>死亡状态（TERMINATED）</strong></p><p>线程执行完了或者因异常退出了 `run() 方法，该线程结束生命周期。</p></blockquote><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/1539204-20190625104746568-573625770-20210916175419041.png"></p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a><u>Synchronized</u></h1><p class="note note-primary">重要</p><blockquote><p>线程同步机制，同一时刻，最多有一个线程访问某个内存地址，直到该线程完成操作，其他线程才能对这个内存地址进行操作，以保证数据的完整性。</p></blockquote><blockquote><p><strong><u>Synchronized</u></strong></p><ol><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123; <span class="hljs-comment">// 得到对象的锁，才能操作同步代码  // 需要被同步的代码&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>放在方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span> <span class="hljs-params">(String name)</span> </span>&#123;  <span class="hljs-comment">// 需要被同步的代码&#125;</span><br></code></pre></td></tr></table></figure></li></ol></blockquote><p>解决：售票问题的同步问题</p><ul><li><p>代码块加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        SellTicket03 s = <span class="hljs-keyword">new</span> SellTicket03();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(s);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loop = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>      <span class="hljs-keyword">while</span>(loop) &#123;<br>        sell();<br>&#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 代码块上加锁</span><br>  <span class="hljs-comment">// 锁加在 this 对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 同步方法，同一时刻，只能有一个线程来执行 sell 方法</span><br>      <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>          System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>          loop = <span class="hljs-keyword">false</span>;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 休眠50ms</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>                           + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>      &#125;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法上加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        SellTicket03 s = <span class="hljs-keyword">new</span> SellTicket03();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(s);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loop = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>      <span class="hljs-keyword">while</span>(loop) &#123;<br>        sell();<br>&#125;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 方法上加锁</span><br>  <span class="hljs-comment">// public synchronized void sell() 同步方法</span><br>  <span class="hljs-comment">// 锁加在 this 对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 同步方法，同一时刻，只能有一个线程来执行 sell 方法</span><br>      <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>        loop = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 休眠50ms</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>                         + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><u>互斥锁</u></h1><p class="note note-primary">重要</p><blockquote><p>作用是保证共享数据的完整性；</p><p>每个对象都对应于一个可称为 “互斥锁” 的标记，这个标记用于保证在同一时刻，只能有一个线程访问该对象；</p><p>关键字 synchronized 与对象互斥锁联系，当某个对象用 synchronized 修饰时，表面该对象任一时刻都只能由一个线程访问；</p><p>同步的局限性：导致程序的执行效率要降低；</p><p>同步方法（非静态）的锁可以是 this，也可以是其他对象（要求是同一个对象）；</p><p>同步方法（静态的）的锁为当前类本身，当前类.class。</p></blockquote><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>模拟死锁的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock_</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//模拟死锁现象</span><br>    DeadLockDemo A = <span class="hljs-keyword">new</span> DeadLockDemo(<span class="hljs-keyword">true</span>); A.setName(<span class="hljs-string">&quot;A 线程&quot;</span>);<br>    DeadLockDemo B = <span class="hljs-keyword">new</span> DeadLockDemo(<span class="hljs-keyword">false</span>); B.setName(<span class="hljs-string">&quot;B 线程&quot;</span>);<br>    A.start();<br>    B.start();<br>  &#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> Object o1 = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 保证多线程，共享一个对象,这里使用 static </span><br>  <span class="hljs-keyword">static</span> Object o2 = <span class="hljs-keyword">new</span> Object();<br>  <span class="hljs-keyword">boolean</span> flag;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLockDemo</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>&#123; <span class="hljs-comment">// 构造器 </span><br>    <span class="hljs-keyword">this</span>.flag = flag;<br>&#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 下面业务逻辑的分析</span><br>    <br>    <span class="hljs-comment">// 如果 flag 为 T, 线程 A 就会先持有 o1 对象锁, 然后尝试去获取 o2 对象锁 </span><br>    <span class="hljs-comment">// 如果线程 A 得不到 o2 对象锁，就会 Blocked</span><br>    <br>    <span class="hljs-comment">// 如果 flag 为 F, 线程 B 就会先持有 o2 对象锁, 然后尝试去获取 o1 对象锁 </span><br>    <span class="hljs-comment">// 如果线程 B 得不到 o1 对象锁，就会 Blocked</span><br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      <span class="hljs-keyword">synchronized</span> (o1) &#123;<span class="hljs-comment">//对象互斥锁, 下面就是同步代</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 1&quot;</span>); <br>        <span class="hljs-keyword">synchronized</span> (o2) &#123;<br>          <span class="hljs-comment">// 这里获得 li 对象的监视权</span><br>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 2&quot;</span>); &#125;<br>      &#125; <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">synchronized</span> (o2) &#123; <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 3&quot;</span>); <br>        <span class="hljs-keyword">synchronized</span> (o1) &#123; <span class="hljs-comment">// 这里获得 li 对象的监视权</span><br>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 4&quot;</span>); <br>        &#125;<br>      &#125; <br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><blockquote><p>释放锁的操作</p><p>当前线程的同步方法、同步代码块执行结束；</p><p>当前线程在同步方法、同步代码块中遇到 break、return；</p><p>当前线程在同步方法、同步代码块中出现了未处理的 Error 或者 Exception；</p><p>当前线程在同步方法、同步代码块中执行了 <code>wait()</code> 方法，使得线程暂停，并释放锁。</p><p>不会释放锁的操作</p><p>线程的同步方法、同步代码块执行 <code>Thread.sleep()</code>、<code>Thread.yield()</code>；</p><p>线程执行同步代码块，其他线程调用该线程的 <code>suspend()</code> 方法将该线程挂起。</p></blockquote><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。 </p><blockquote><ol><li><p>竞争资源 例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。 </p><p>系统中的资源可以分为两类：</p><ul><li>可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源； </li><li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。 </li></ul></li><li><p>进程推进顺序不当 </p><p>例如：进程 A 和 进程 B 互相等待对方的数据。</p></li></ol></blockquote><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><blockquote><ol><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用；</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放；</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ol></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1zB4y1A7rb?p=17">韩顺平-Java线程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2020/10/10/springmvc/"/>
    <url>/2020/10/10/springmvc/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分。</p><ul><li><p>M：Model，模型层</p><p>指工程中的 JavaBean，作用是处理数据。</p><p>JavaBean 分为两类：</p><ul><li>一类称为实体类 Bean：专门存储业务数据的，如 Student、User 等。</li><li>一类称为业务处理  Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul></li><li><p>V：View，视图层</p><p>指工程中的 html 或 jsp 等页面，作用是与用户进行交互，展示数据。</p></li><li><p>C：Controller，控制层</p><p>指工程中的 servlet，作用是接收请求和响应浏览器。</p></li></ul><blockquote><p><strong>工作流程</strong><br>用户通过视图层发送请求到服务器，在服务器中请求被 Controller 接收，Controller 调用相应的 Model 层处理请求，处理完毕将结果返回到 Controller，Controller 再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p></blockquote><h3 id="SpringMVC-1"><a href="#SpringMVC-1" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。</p><p><strong>特点</strong></p><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接；</li><li><strong>基于原生的 Servlet</strong>，通过了功能强大的<strong>前端控制器 DispatcherServlet</strong>，对请求和响应进行统一处理；</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong>；</li><li><strong>代码清新简洁</strong>，大幅度提升开发效率；</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可；</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求。</li></ul><h2 id="SpringMVC简单入门"><a href="#SpringMVC简单入门" class="headerlink" title="SpringMVC简单入门"></a>SpringMVC简单入门</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p>开发步骤：</p><ol><li>导入 SpringMVC 依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- Spring --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- SpringMVC --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Jsp --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>web.xml</code> 中配置 SpringMVC 核心控制器 <strong><u>DispathcerServlet</u></strong> ，SpringMVC 的配置文件默认位于 WEB-INF 下，默认名称为 &lt;servlet-name&gt;-servlet.xml。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringMVC前端控制器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span><br><span class="hljs-comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span><br><span class="hljs-comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><br><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><br><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>关于 &lt;url-pattern&gt;/&lt;/url-pattern&gt;</p><ul><li>/ 所匹配的请求可以是 /login 或 .html 或 .js 或 .css 方式的请求路径，但是 / 不能匹配 .jsp 请求路径的请求。因此就可以避免在访问 jsp 页面时，该请求被 <strong><u>DispatcherServlet</u></strong> 处理，从而找不到相应的页面。</li><li>/* 则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用 /* 的写法。</li></ul></blockquote><ol start="3"><li>创建 Controller 类和视图页面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;quick method running...&quot;</span>);        <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>使用注解配置 Controller 类中业务方法的映射地址</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>配置SpringMVC核心文件 <code>spring-mvc.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 自动扫描包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.tsuiraku.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><br>                        <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><br>                        <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">     处理静态资源，例如html、js、css、jpg</span><br><span class="hljs-comment">     若只设置该标签，则只能访问静态资源，其他请求则无法访问</span><br><span class="hljs-comment">     此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 开启mvc注解驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultCharset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6"><li>客户端发起请求测试</li></ol><p><strong>流程演示</strong></p><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-08-19%2019.16.34.png"></p><h1 id="SpringMVC的注解解析"><a href="#SpringMVC的注解解析" class="headerlink" title="SpringMVC的注解解析"></a>SpringMVC的注解解析</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>作用：用于建立请求 URL 和处理请求方法之间的对应关系。</p><p>位置</p><ul><li><p>类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录；</p></li><li><p>方法上，请求 URL 的第二级访问目录，与类上的使用 @ReqquestMapping 标注的一级目录一起组成访问虚拟路径。</p></li></ul><p>属性</p><ul><li>**<u>value</u>**：用于指定请求的 URL。它和 path 属性的作用是一样的；</li><li>**<u>method</u>**：用于指定请求的方式，<code>method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</code>；（匹配不成功 —&gt; 405）</li><li>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。（匹配不成功 —&gt; 400）</li><li>headers：属性通过请求的请求头信息匹配请求映射。（匹配不成功 —&gt; 404）</li></ul><blockquote><p><u><strong>value</strong></u></p><p>支持 ant 风格的路径</p><ul><li>？：表示任意的单个字符</li><li>*：表示任意的0个或多个字符*</li><li>**：表示任意的一层或多层目录</li></ul><p>支持路径中的占位符</p><ul><li><p>原始方式：/deleteUser?id=1</p></li><li><p>Rest方式：/deleteUser/1</p></li></ul><p><strong><u>method</u></strong></p><ol><li><p>对于处理指定请求方式的控制器方法，SpringMVC 中提供了 @RequestMapping 的派生注解</p><ul><li><p>处理 get 请求的映射–&gt;@GetMapping</p></li><li><p>处理 post 请求的映射–&gt;@PostMapping</p></li><li><p>处理 put 请求的映射–&gt;@PutMapping</p></li><li><p>处理 delete 请求的映射–&gt;@DeleteMapping</p></li></ul></li><li><p>常用的请求方式有 <strong><u>get、post、put、delete</u></strong></p><ul><li><p>但是目前浏览器只支持 get 和 post ，若在 form 表单提交时，为 method 设置了其他请求方式的字符串（put或delete），则按照默认的请求方式 get 处理；</p></li><li><p>若要发送 put 和 delete 请求，则需要通过 Spring 提供的过滤器 **<u>HiddenHttpMethodFilter</u>**，在RESTful部分会讲到。</p></li></ul></li></ol><p><strong>param</strong></p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数；</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数；</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value；</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value。</p><p><strong>headers</strong></p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息；</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息；</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value；</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value。</p></blockquote><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><a href="#@RequestParam%E6%B3%A8%E8%A7%A3">@RequestParam</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a><a href="#@RequestHeader%E6%B3%A8%E8%A7%A3">@RequestHeader</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a><a href="#@CookieValue%E6%B3%A8%E8%A7%A3">@CookieValue</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><a href="#PathVariable%E6%B3%A8%E8%A7%A3">@PathVariable</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><a href="#@RequestBody%E6%B3%A8%E8%A7%A3">@RequestBody</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a><a href="#@RequestBody%E6%B3%A8%E8%A7%A3">@ResponseBody</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a><a href="#@RestController%E6%B3%A8%E8%A7%A3">@RestController</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a><a href="#@ControllerAdvice%E6%B3%A8%E8%A7%A3">@ControllerAdvice</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a><a href="#@ExceptionHandler%E6%B3%A8%E8%A7%A3">@ExceptionHandler</a></h2><p class="note note-info">点击标题跳转到详情</p><h1 id="SpringMVC-xml"><a href="#SpringMVC-xml" class="headerlink" title="SpringMVC.xml"></a>SpringMVC.xml</h1><h2 id="Controller注解扫描"><a href="#Controller注解扫描" class="headerlink" title="@Controller注解扫描"></a>@Controller注解扫描</h2><p><strong><u>&lt;context:componet-scan base-pacakage=”com.xxx.xxx”&gt; &lt;/context:componet-scan&gt;</u></strong></p><h2 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a><u>注解驱动</u></h2><p><strong><u>&lt;mvc:annotation-driven/&gt;</u></strong></p><p>开启 mvc 注解驱动。如果不开启注解驱动，那么所有的请求将会被默认 Servlet 处理。</p><p>搭配：**<u>&lt;mvc:default-servlet-handler&gt;</u>**（开启默认 Servlet，开启对静态资源的访问）。</p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a><a href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8(ViewResolver)">视图解析器</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="文件解析器"><a href="#文件解析器" class="headerlink" title="文件解析器"></a>文件解析器</h2><p><strong><u>multipartResolver</u></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 必须通过文件解析器的解析才能将文件转换为MultipartFile对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><a href="#SpringMVC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a><a href="#SpringMVC%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8">异常处理器</a></h2><p class="note note-info">点击标题跳转到详情</p><h1 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h1><blockquote><p>客户端请求参数的格式是：<code>name=value&amp;name=value…</code></p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC 可以接收如下类型的参数</p><ul><li>基本类型参数</li><li>POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul></blockquote><h2 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h2><p class="note note-warning">不建议使用</p><p>将 HttpServletRequest 作为控制器方法的形参，此时 HttpServletRequest 类型的参数表示封装了当前请求的请求报文的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="控制器方法的形参"><a href="#控制器方法的形参" class="headerlink" title="控制器方法的形参"></a>控制器方法的形参</h2><p>在控制器方法的形参位置，**<u>设置和请求参数同名的形参</u>**，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet 中就会将请求参数赋值给相应的形参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(String username, String password)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数；</li><li>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据；</li><li>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果。</li></ul><h2 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h2><p> <span id = "@RequestParam注解"></span></p><p>当请求的参数名称与 Controller 的业务方法参数名称不一致时，就需要通过 @RequestParam 注解显示的绑定。</p><p>@RequestParam 是将请求参数和控制器方法的形参创建映射关系。</p><blockquote><p><strong>value</strong>：指定为形参赋值的请求参数的参数名；</p><p><strong>required</strong>：设置是否必须传输此请求参数，默认值为 true；</p><ul><li>若 <code>required=true</code> 时，则当前请求必须传输 value 所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue 属性，则页面报错400：<code>Required String parameter &#39;xxx&#39; is not present</code>；</li><li>若 <code>required=false</code>，则当前请求不是必须传输 value 所指定的请求参数，若没有传输，则注解所标识的形参的值为 null。</li></ul><p><strong>defaultValue</strong>：不管 required 属性值为 true 或 false ，当 value 所指定的请求参数没有传输或传输的值为空字符串时，则使用默认值为形参赋值。</p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;  <br>  &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;br&gt;  <br>  &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;&lt;br&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTest</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span>String username)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  System.out.println(username);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="@RequestHeader注解"></a>@RequestHeader注解</h2><p> <span id = "@RequestHeader注解"></span></p><p>@RequestHeader 是将请求头信息和控制器方法的形参创建映射关系。    </p><blockquote><ul><li><strong>value</strong>：请求头的名称；</li><li><strong>required</strong>：是否必须携带此请求头。</li><li><strong>defaultValue</strong>。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParam</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  // 获取请求头 User-Agent </span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-meta">@RequestHeader(value = &quot;User-Agent&quot;, required = false)</span> String headerValue)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="CookieValue注解"><a href="#CookieValue注解" class="headerlink" title="@CookieValue注解"></a>@CookieValue注解</h2><p> <span id = "@CookieValue注解"></span></p><p>@CookieValue 是将 cookie 数据和控制器方法的形参创建映射关系。使用 @CookieValue 可以获得指定Cookie的值。</p><blockquote><ul><li><strong>value</strong>：指定 cookie 的名称；</li><li><strong>required</strong>：是否必须携带此 cookie；</li><li><strong>defaultValue</strong>。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParam</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;JSESSIONID&quot;, required = false)</span> String headerValue)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="POJO类型"><a href="#POJO类型" class="headerlink" title="POJO类型"></a>POJO类型</h2><p>可以在控制器方法的形参位置设置一个实体类类型的形参。Controller 中的业务方法的 POJO 参数的属性名与请求参数的 name 一致，参数值会自动映射匹配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">User</span><span class="hljs-params">()</span></span>&#123;  <br>  <span class="hljs-keyword">private</span> Integer id;  <br>  <span class="hljs-keyword">private</span> String username;  <br>  <span class="hljs-keyword">private</span> String password;  <br>  <span class="hljs-keyword">private</span> Integer age;  <br>  <span class="hljs-keyword">private</span> String sex; <br>  <span class="hljs-keyword">private</span> String email; <br>  <br>  <span class="hljs-comment">// 生成 set/get 方法</span><br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParam</span><span class="hljs-params">(User user)</span> </span>&#123;  <br>  System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h2><p>获得集合参数时，要将集合参数包装到一个 POJO 中才可以。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[0].username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[0].age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[1].username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[1].age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class Vo&#123;  <br>  <span class="hljs-keyword">private</span> List&lt;User&gt; userList;  <br>  <span class="hljs-comment">// set/get</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTest</span><span class="hljs-params">(Vo vo)</span> </span>&#123;<br>  System.out.println(vo.getUserList());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="请求参数的乱码问题"><a href="#请求参数的乱码问题" class="headerlink" title="请求参数的乱码问题"></a>请求参数的乱码问题</h2><h3 id="CharacterEncodingFilter"><a href="#CharacterEncodingFilter" class="headerlink" title="CharacterEncodingFilter"></a><u><strong>CharacterEncodingFilter</strong></u></h3><p>当 <u><strong>get</strong></u> 请求，可以在 tomcat 中 server.xml 中修改配置。</p><p>当 <strong><u>post</u></strong> 请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。使用 SpringMVC 提供的编码过滤器 CharacterEncodingFilter。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置CharacterEncodingFilter --&gt;</span><br><span class="hljs-comment">&lt;!-- web.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>SpringMVC 中处理编码的过滤器一定要配置到其他过滤器之前，否则无效。</li></ul><h1 id="SpringMVC的域对象共享数据"><a href="#SpringMVC的域对象共享数据" class="headerlink" title="SpringMVC的域对象共享数据"></a>SpringMVC的域对象共享数据</h1><h2 id="向request域对象中共享数据"><a href="#向request域对象中共享数据" class="headerlink" title="向request域对象中共享数据"></a>向request域对象中共享数据</h2><p>根据共享数据的键获取数据。</p><h3 id="ServletAPI-1"><a href="#ServletAPI-1" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><p class="note note-warning">不建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testServletAPI&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testServletAPI</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello servletAPI&quot;</span>); <span class="hljs-comment">// 设置域共享数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p class="note note-primary">重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">testModelAndView</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Model：主要用于向请求域共享数据</span><br><span class="hljs-comment">     * View：主要用于设置视图，实现页面跳转</span><br><span class="hljs-comment">     */</span><br>    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();<br>    <span class="hljs-comment">// 向请求域共享数据</span><br>    mav.addObject(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello ModelAndView&quot;</span>);<br>    <span class="hljs-comment">// 设置视图，实现页面跳转</span><br>    mav.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> mav;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModel&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModel</span><span class="hljs-params">(Model model)</span></span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello Model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testMap&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>&#123;<br>    map.put(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello Map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelMap&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModelMap</span><span class="hljs-params">(ModelMap modelMap)</span></span>&#123;<br>    modelMap.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello ModelMap&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Model-amp-ModelMap-amp-Map的关系"><a href="#Model-amp-ModelMap-amp-Map的关系" class="headerlink" title="Model &amp; ModelMap &amp; Map的关系"></a>Model &amp; ModelMap &amp; Map的关系</h2><p>Model、ModelMap、Map 类型的参数其实本质上都是 <strong><u>BindingAwareModelMap</u></strong> 类型的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 继承关系</span><br>public interface <span class="hljs-type">Model</span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap&lt;String</span>, <span class="hljs-title">Object&gt;</span> </span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendedModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ModelMap</span> <span class="hljs-title">implements</span> <span class="hljs-title">Model</span> </span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindingAwareModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExtendedModelMap</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><p>根据 session.key 获取数据。</p><h3 id="ServletAPI-2"><a href="#ServletAPI-2" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><p class="note note-info">建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testSession&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testSession</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;testSessionScope&quot;</span>, <span class="hljs-string">&quot;hello session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="向application域共享数据"><a href="#向application域共享数据" class="headerlink" title="向application域共享数据"></a>向application域共享数据</h2><p>对应整个工程域范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testApplication&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testApplication</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>  <span class="hljs-comment">// ServletContext</span><br>  ServletContext application = session.getServletContext();<br>    application.setAttribute(<span class="hljs-string">&quot;testApplicationScope&quot;</span>, <span class="hljs-string">&quot;hello application&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h1><p>SpringMVC 中的视图是 View 接口，视图的作用渲染数据，将模型Model中的数据展示给用户。</p><p>SpringMVC 视图的种类很多，默认有转发视图（InternalResourceView）和重定向视图（RedirectView）。</p><p>若使用的视图技术为 Thymeleaf，在 SpringMVC 的配置文件中配置了 Thymeleaf 的视图解析器，由此视图解析器解析之后所得到的是 ThymeleafView。</p><h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被 SpringMVC 配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="hljs-comment">&lt;!-- ThymeleafViewResolver --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><br>                      <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><br>                      <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h2><p><strong><u>InternalResourceView</u></strong></p><p>当 Controller 方法中所设置的视图名称以 <code>forward:</code> 为前缀时，创建InternalResourceView 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>forward:</code> 去掉，剩余部分作为最终路径通过转发的方式实现跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/testForward&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testForward</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h2><p><strong><u>RedirectView</u></strong></p><p>当 Controller 方法中所设置的视图名称以 <code>redirect:</code> 为前缀时，创建 RedirectView 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>redirect:</code> 去掉，剩余部分作为最终路径通过重定向的方式实现跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/testRedirect&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedirect</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><p><strong><u>view-controller</u></strong></p><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用 view-controller 标签进行表示。</p><p>当 SpringMVC 中设置任何一个 view-controller 时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC 的核心配置文件中设置开启 mvc 注解驱动的标签：**<u>&lt;mvc:annotation-driven /&gt;</u>**。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">path：设置处理的请求地址</span><br><span class="hljs-comment">view-name：设置请求地址所对应的视图名称</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-comment">&lt;!-- springMVC.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testView&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="视图解析器（ViewResolver）"><a href="#视图解析器（ViewResolver）" class="headerlink" title="视图解析器（ViewResolver）"></a>视图解析器（ViewResolver）</h2><p><span id="视图解析器(ViewResolver)"></span></p><p><strong><u>ViewResolver</u></strong></p><p><strong><u>InternalResourceViewResolver</u></strong></p><p>该解析器的默认设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">REDIRECT_URL_PREFIX = <span class="hljs-string">&quot;redirect:&quot;</span>  --重定向前缀<br>FORWARD_URL_PREFIX = <span class="hljs-string">&quot;forward:&quot;</span>    --转发前缀（默认值）<br>prefix = <span class="hljs-string">&quot;&quot;</span>;     --视图名称前缀<br>suffix = <span class="hljs-string">&quot;&quot;</span>;     --视图名称后缀<br></code></pre></td></tr></table></figure><p><code>springMVC.xml</code> 配置中通过属性注入的方式修改视图的的前后缀</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置内部资源视图解析器 --&gt;</span><br><span class="hljs-comment">&lt;!-- 解析JSP视图 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><p><strong>资源</strong></p><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个 URI 来标识。URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互。</p><p><strong>资源的表述</strong></p><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><p><strong>状态转移</strong></p><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><p>Restful 是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用 <strong>“<u>url+请求方式</u>”</strong> 表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><ul><li><p>GET：用于获取资源</p></li><li><p>POST：用于新建资源</p></li><li><p>PUT：用于更新资源</p></li><li><p>DELETE：用于删除资源 </p></li></ul><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td><code>getUserById?id=1</code></td><td><code>user/1</code> get请求方式</td></tr><tr><td>保存操作</td><td><code>saveUser</code></td><td><code>user</code> post请求方式</td></tr><tr><td>删除操作</td><td><code>deleteUser?id=1</code></td><td><code>user/1</code> elete请求方式</td></tr><tr><td>更新操作</td><td><code>updateUser</code></td><td><code>user</code> put请求方式</td></tr></tbody></table><p>上述 url 地址 <code>/user/1</code> 中的 1 就是要获得的请求参数，在 SpringMVC 中可以使用占位符进行参数绑定。地址 <code>/user/1</code> 可以写成 <code>/user/&#123;id&#125;</code>，占位符 {id} 对应的就是 1 的值。在业务方法中我们可以使用 <strong><u>@PathVariable</u></strong> 注解进行占位符的匹配获取工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span></span>&#123;<br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.GET)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getUserAll</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>  <br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot; method = RequestMethod.GET)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>  &#125;<br>  <br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.POST)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>  <br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * PUT 和 DELETE 的条件</span><br><span class="hljs-comment">  * POST</span><br><span class="hljs-comment">  * _method</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.PUT)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>  <br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.DELETE)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a><u>HiddenHttpMethodFilter</u></h2><p>由于浏览器只支持发送 get 和 post 方式的请求，那么该如何发送 put 和 delete 请求。</p><p>SpringMVC 提供了 <strong><u>HiddenHttpMethodFilter</u></strong> 帮助我们**<u>将 POST 请求转换为 DELETE 或 PUT 请求</u>**。</p><p><strong><u>HiddenHttpMethodFilter</u></strong> 处理put和delete请求的条件：</p><ul><li><p>当前请求的请求方式必须为 post；</p></li><li><p>当前请求必须传输请求参数 _method。</p></li></ul><p>注册 <strong>HiddenHttpMethodFilter</strong> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- web.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意！必须先注册 **<u>CharacterEncodingFilter</u>**，再注册 <u><strong>HiddenHttpMethodFilter</strong></u>。</p><p>原因</p><ul><li><p>在 <strong><u>CharacterEncodingFilter</u></strong> 中通过 <code>request.setCharacterEncoding(encoding)</code> 方法设置字符集的；</p></li><li><p><code>request.setCharacterEncoding(encoding)</code> 方法要求前面不能有任何获取请求参数的操作；</p></li><li><p>而 <u><strong>HiddenHttpMethodFilter</strong></u> 恰恰有一个获取请求方式的操作 <code>String paramValue = request.getParameter(this.methodParam);</code>。</p></li></ul></blockquote><h2 id="PathVariable注解"><a href="#PathVariable注解" class="headerlink" title="@PathVariable注解"></a>@PathVariable注解</h2><p> <span id = "@PathVariable注解"></span></p><p>@PathVariable 可以用来映射 URL 中的占位符到目标方法的参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;testPathVariable:&quot;</span>+id);<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h1><h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a><u>HttpMessageConverter</u></h2><p>**<u>HttpMessageConverter</u>**，报文信息转换器，将请求报文转换为 Java 对象，或将 Java 对象转换为响应报文。</p><p><u>HttpMessageConverter</u> 提供了两个注解和两个类型。</p><p>@RequestBody，@ResponseBody，RequestEntity，ResponseEntity。</p><h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h2><p> <span id = "@RequestBody注解"></span></p><p>@RequestBody 可以获取<strong>请求体</strong>，需要在 Controller 方法设置一个形参，使用 @RequestBody 进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestBody&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String requestBody)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;requestBody:&quot;</span>+requestBody);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// requestBody:username=admin&amp;password=123456</span><br></code></pre></td></tr></table></figure><h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><p>RequestEntity 是封装<strong>请求报文</strong>的一种类型，需要在 Controller 方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 <code>getHeaders()</code> 获取请求头信息，通过 <code>getBody()</code> 获取请求体信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestEntity</span><span class="hljs-params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());<br>    System.out.println(<span class="hljs-string">&quot;requestBody:&quot;</span>+requestEntity.getBody());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="@ResponseBody注解"></a>@ResponseBody注解</h2><p> <span id = "@ResponseBody注解"></span></p><p>@ResponseBody 用于标识一个 Controller 方法，可以将该方法的返回值直接作为<strong>响应报文</strong>的响应体响应到浏览器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseBody&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testResponseBody</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="响应Json数据"><a href="#响应Json数据" class="headerlink" title="响应Json数据"></a>响应Json数据</h2><p>当 Java 对象作为返回值进行响应，会出现 HttpMessageNotWritableException 异常。需要将数据转化成 json 格式返回。</p><blockquote><ul><li><p>导入 <strong><u>jackson</u></strong> 依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>开启 mvc 注解驱动；</p><p>（在 <strong><u>HandlerAdaptor</u></strong> 中会自动装配一个消息转换器：**<u>MappingJackson2HttpMessageConverter</u>**，可以将响应到浏览器的 Java 对象转换为 json 格式的字符串）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 Controller 方法上使用 @ResponseBody 注解进行标识；</p></li><li><p>将 Java 对象直接作为 Controller 方法返回，自动转换为 json 格式字符串。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseUser&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">testResponseUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 浏览器的页面中展示的结果</span><br><span class="hljs-comment">// &#123;&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h2><p> <span id = "@RestController注解"></span></p><p>@RestController 注解是 SpringMVC 提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller 注解，并且为其中的每个方法添加了@ResponseBody 注解。</p><h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><p>ResponseEntity 用于 Controller 方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文。</p><p>（用于实现文件下载）</p><h1 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>使用 ResponseEntity 实现下载文件的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testDown&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 获取 ServletContext 对象</span><br>    ServletContext servletContext = session.getServletContext();<br>    <span class="hljs-comment">// 获取服务器中文件的真实路径</span><br>    String realPath = servletContext.getRealPath(<span class="hljs-string">&quot;/static/img/1.jpg&quot;</span>);<br>    <span class="hljs-comment">// 创建输入流</span><br>    InputStream is = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>    <span class="hljs-comment">// 创建字节数组</span><br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[is.available()];<br>    <span class="hljs-comment">// 将流读到字节数组中</span><br>    is.read(bytes);<br>    <span class="hljs-comment">// 创建HttpHeaders对象设置响应头信息</span><br>    MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> HttpHeaders();<br>    <span class="hljs-comment">// 设置要下载方式以及下载文件的名字</span><br>    headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=1.jpg&quot;</span>);<br>    <span class="hljs-comment">// 设置响应状态码</span><br>    HttpStatus statusCode = HttpStatus.OK;<br>    <span class="hljs-comment">// 创建 ResponseEntity 对象</span><br>    ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; responseEntity = <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);<br>    <span class="hljs-comment">// 关闭输入流</span><br>    is.close();<br>    <span class="hljs-keyword">return</span> responseEntity;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传要求 form 表单的请求方式必须为 <strong>post</strong>，并且添加属性 <code>enctype=&quot;multipart/form-data&quot;</code> ，SpringMVC 中将上传的文件封装到 <strong><u>MultipartFile</u></strong> 对象中，通过此对象可以获取文件相关信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- thymeleay视图解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testUp&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>  头像：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;photo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><p>导入 <strong><u>commons-fileupload</u></strong> 依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 SpringMVC 的配置文件中添加配置；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 必须通过文件解析器的解析才能将文件转换为MultipartFile对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Controller 方法（接受形参名与提交的名一致）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testUp&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testUp</span><span class="hljs-params">(MultipartFile photo, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 获取上传的文件的文件名</span><br>    String fileName = photo.getOriginalFilename();<br>    <span class="hljs-comment">// 处理文件重名问题</span><br>  <span class="hljs-comment">// 获取上传文件后缀名</span><br>    String hzName = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>    fileName = UUID.randomUUID().toString() + hzName;<br>    <span class="hljs-comment">// 获取服务器中photo目录的路径</span><br>    ServletContext servletContext = session.getServletContext();<br>    String photoPath = servletContext.getRealPath(<span class="hljs-string">&quot;photo&quot;</span>);<br>    File file = <span class="hljs-keyword">new</span> File(photoPath);<br>    <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>        file.mkdir();<br>    &#125;<br>    String finalPath = photoPath + File.separator + fileName;<br>    <span class="hljs-comment">// 实现上传功能</span><br>    photo.transferTo(<span class="hljs-keyword">new</span> File(finalPath));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h1 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h1><p><span id="SpringMVC的拦截器"></span></p><p>SpringMVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行 <strong>预处理（preHandler）</strong> 和<strong>后处理（postHandler）</strong>。</p><p>将拦截器按一定的顺序联结成一条链，这条链称为<strong>拦截器链（Interceptor Chain）</strong>。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是 AOP 思想的具体实现。</p><p><strong>拦截器与过略器的区别</strong></p><table><thead><tr><th><strong>区别</strong></th><th><strong>过滤器</strong></th><th><strong>拦截器</strong></th></tr></thead><tbody><tr><td>使用范围</td><td>是 servlet 规范中的一部分，任何 Java Web 工程都可以使用</td><td>是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用</td></tr><tr><td>拦截范围</td><td>在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截</td><td>只会拦截访问的控制器方法，如果访问的是 jsp、html、css、image、js 是不会进行拦截的</td></tr></tbody></table><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-09-18%2015.53.35.png" style="zoom:50%;" /><p><em><strong>即对 DispatchServlet 所处理的所有请求进行拦截。</strong></em></p><p><strong>配置使用拦截器。</strong></p><ul><li>创建拦截器类实现 <code>HandlerInterceptor</code> 接口<ul><li><code>preHandle</code><ul><li>目标方法执行前执行；</li></ul></li><li><code>postHandle</code><ul><li>目标方法执行后，视图返回前返回前执行；</li></ul></li><li><code>afterCompletion</code><ul><li>整个流程执行后执行。</li></ul></li></ul></li></ul><p><strong><u>HandlerInterceptor</u></strong></p><p>SpringMVC 中的拦截器用于拦截控制器方法的执行，SpringMVC 中的拦截器需要实现 **<u>HandlerInterceptor</u>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>  <span class="hljs-comment">// 返回 true：放行 </span><br>  <span class="hljs-comment">// 返回 false：拦截</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse </span></span><br><span class="hljs-params"><span class="hljs-function">        response, Object handler)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;preHandle running...&quot;</span>);<br>    String param = request.getParametr(<span class="hljs-string">&quot;param&quot;</span>);<br>    <span class="hljs-keyword">if</span>(parma.equals(<span class="hljs-string">&quot;yes&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      request.getRequestDisaptcher(<span class="hljs-string">&quot;/error.jsp&quot;</span>).forward(request, response);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>  &#125;<br>  <span class="hljs-comment">// 可以在此方法修改视图 modelAndView</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse </span></span><br><span class="hljs-params"><span class="hljs-function">        response, Object handler, ModelAndView modelAndView)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;postHandle running...&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse </span></span><br><span class="hljs-params"><span class="hljs-function">        response, Object handler, Exception ex)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;afterCompletion running...&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置注册拦截器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springMVC.xml --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testRequestEntity&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tsuiraku.interceptor.MyHandlerInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用ref --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testRequestEntity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;MyHandlerInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <em><strong>&lt;bean&gt;</strong></em> 配置拦截器，此时所有的请求都会经过 <em><strong>MyHandlerInterceptor</strong></em> 拦截器。</p><p>使用 <em><strong>&lt;ref&gt;</strong></em> 配置拦截器，此时所有的请求都会经过 <em><strong>MyHandlerInterceptor</strong></em> 拦截器。</p><p>当只使用以上两种方式之一，此时会对所有请求路径进行拦截。</p><p>当使用 *<strong>&lt;mvc:mapping*&gt;</strong> ，指定需要拦截的请求路径。</p><p>当使用 ***&lt;mvc:exclude-mapping&gt;***，指定放行的请求路径。</p><p><strong>拦截器的三个方法。</strong></p><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>preHandle()</strong></td><td align="left">方法将在请求处理之前进行调用，该方法的返回值是布尔值 Boolean 类型的。当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时就会继续调用下一个Interceptor 的 preHandle 方法。</td></tr><tr><td align="center"><strong>postHandle()</strong></td><td align="left">该方法是在当前请求进行处理之后被调用，前提是 preHandle 方法的返回值为true 时才能被调用，且它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作。</td></tr><tr><td align="center"><strong>afterCompletion()</strong></td><td align="left">该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行，前提是 preHandle 方法的返回值为true 时才能被调用。</td></tr></tbody></table><p><em><strong>当有多个拦截器时，执行顺序。</strong></em></p><ul><li><strong>preHandler</strong> 按照顺序执行；</li><li> <em><strong>postHandler</strong></em> 和 <em><strong>afterCompletion</strong></em> 按照反序执行。</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">O<span class="hljs-function"><span class="hljs-title">neHandlerInterceptor</span> -&gt;</span> preHandler<br>T<span class="hljs-function"><span class="hljs-title">woHandlerInterceptor</span> -&gt;</span> preHandler<br>T<span class="hljs-function"><span class="hljs-title">woHandlerInterceptor</span> -&gt;</span> postHandler<br>O<span class="hljs-function"><span class="hljs-title">neHandlerInterceptor</span> -&gt;</span> postHandler<br>T<span class="hljs-function"><span class="hljs-title">woHandlerInterceptor</span> -&gt;</span> afterCompletion<br>O<span class="hljs-function"><span class="hljs-title">neHandlerInterceptor</span> -&gt;</span> afterCompletion<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的异常处理器"><a href="#SpringMVC的异常处理器" class="headerlink" title="SpringMVC的异常处理器"></a>SpringMVC的异常处理器</h1><p><span id="SpringMVC的异常处理器"></span></p><p><strong><u>HandlerExceptionResolver</u></strong></p><p>系统中异常包括两类：<strong>预期异常</strong>和<strong>运行时异常（RuntimeException）</strong>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的 <strong>Dao</strong>、<strong>Service</strong>、<strong>Controller</strong> 出现都通过 throws Exception 向上抛出，最后由 SpringMVC 前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20210821171506546.png"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p><strong>自定义异常处理的方式</strong></p><ul><li><p>使用 Spring MVC 提供的简单异常处理器 <strong><u>SimpleMappingExceptionResolver</u></strong></p></li><li><p>实现 Spring 的异常处理接口 <strong><u>HandlerExceptionResolver</u></strong> 自定义自己的异常处理器</p></li></ul><h2 id="基于配置的异常处理"><a href="#基于配置的异常处理" class="headerlink" title="基于配置的异常处理"></a><strong>基于配置的异常处理</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        properties的键表示处理器方法执行过程中出现的异常</span><br><span class="hljs-comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span><br><span class="hljs-comment">        --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionAttribute&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基于注解的异常处理"><a href="#基于注解的异常处理" class="headerlink" title="基于注解的异常处理"></a><strong>基于注解的异常处理</strong></h2><h3 id="ControllerAdvice注解"><a href="#ControllerAdvice注解" class="headerlink" title="@ControllerAdvice注解"></a>@ControllerAdvice注解</h3><p> <span id = "@ControllerAdvice注解"></span></p><p>增强的 Controller 注解。</p><blockquote><ol><li>全局异常处理；</li><li>全局数据绑定；</li><li>全局数据预处理。</li></ol></blockquote><h3 id="ExceptionHandler注解"><a href="#ExceptionHandler注解" class="headerlink" title="@ExceptionHandler注解"></a>@ExceptionHandler注解</h3><p> <span id = "@ExceptionHandler注解"></span></p><p>统一处理某一类异常，从而能够减少代码重复率和复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将当前类标识为异常处理的组件</span><br><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionController</span> </span>&#123;<br><br>    <span class="hljs-comment">// 用于设置所标识方法处理的异常</span><br>    <span class="hljs-meta">@ExceptionHandler(ArithmeticException.class)</span><br>    <span class="hljs-comment">// ex表示当前请求处理中出现的异常对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handleArithmeticException</span><span class="hljs-params">(Exception ex, Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于注解配置SpringMVC"><a href="#基于注解配置SpringMVC" class="headerlink" title="基于注解配置SpringMVC"></a>基于注解配置SpringMVC</h1><p><em><strong>使用配置类和注解代替 web.xml 和 SpringMVC 配置文件的功能</strong></em></p><h2 id="WebInit"><a href="#WebInit" class="headerlink" title="WebInit"></a>WebInit</h2><p><strong><u>AbstractAnnotationConfigDispatcherServletInitializer</u></strong></p><p>在Servlet3.0 环境中，容器会在类路径中查找实现 <em><strong>javax.servlet.ServletContainerInitializer</strong></em> 接口的类，如果能够找到就使用它来配置 Servlet 容器。</p><p>Spring 提供了这个接口的实现，名为 <em><strong>SpringServletContainerInitializer</strong></em>，这个类反过来又会查找实现<em><strong>WebApplicationInitializer</strong></em> 的类并将配置的任务交给它来完成。Spring3.2 引入了一个便利的<em><strong>WebApplicationInitializer</strong></em> 基础实现，即 <em><strong>AbstractAnnotationConfigDispatcherServletInitializer</strong></em>。</p><p>当我们的类扩展了 <em><strong>AbstractAnnotationConfigDispatcherServletInitializer</strong></em> 并将其部署到 Servlet3.0 容器的时候，容器会自动发现它，并用它来配置 Servlet 上下文。</p><p>初始化类 <em><strong>WebInit</strong></em>，代替 <em><strong>web.xml</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定spring的配置类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;SpringConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定SpringMVC的配置类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;WebConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加过滤器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;<br>      <span class="hljs-comment">// 设置字符串过略器</span><br>        CharacterEncodingFilter encodingFilter = <span class="hljs-keyword">new</span> CharacterEncodingFilter();<br>        encodingFilter.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        encodingFilter.setForceRequestEncoding(<span class="hljs-keyword">true</span>);<br>      <span class="hljs-comment">// 设置HiddenHttpMethodFilter</span><br>        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WebConfig"><a href="#WebConfig" class="headerlink" title="WebConfig"></a>WebConfig</h2><p><strong><u>WebMvcConfigurer</u></strong></p><p>初始化类 <em><strong>WebConfig</strong></em>，代替 <em><strong>springMVC.xml</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 代替springMVC.xml</span><br><span class="hljs-comment">* 1. 扫描组件</span><br><span class="hljs-comment">* 2. 视图解析器</span><br><span class="hljs-comment">* 3. view-controller</span><br><span class="hljs-comment">* 4. default-servlet-handler</span><br><span class="hljs-comment">* 5. mvc注解驱动</span><br><span class="hljs-comment">* 6. 文件解析器</span><br><span class="hljs-comment">* 7. 异常处理</span><br><span class="hljs-comment">* 8. 拦截器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@ComponentScan(&quot;com.tsuiraku&quot;)</span> <span class="hljs-comment">// 扫描组件</span><br><span class="hljs-meta">@EnableWebMvc</span> <span class="hljs-comment">// 开启MVC注解驱动</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 使用default-servlet-handler处理静态资源</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span></span>&#123;<br>        configurer.enable(); <span class="hljs-comment">// 开启默认default-servlet-handler</span><br>    &#125;<br>  <br>  <span class="hljs-comment">// 配置view-controller</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewController</span><span class="hljs-params">(ViewControllerRegistry registry)</span></span>&#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/hello&quot;</span>).setViewName(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 配置文件上传解析器</span><br>  <span class="hljs-comment">// （导入依赖）</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonsMultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonsMultipartResolver();<br>    &#125;<br><br>    <span class="hljs-comment">// 配置拦截器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        FirstInterceptor firstInterceptor = <span class="hljs-keyword">new</span> FirstInterceptor();<br>        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置视图控制</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置异常处理器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span></span><br><span class="hljs-function">    </span>&#123;<br>        SimpleMappingExceptionResolver exceptionResolver = <span class="hljs-keyword">new</span><br>          SimpleMappingExceptionResolver();<br>        Properties prop = <span class="hljs-keyword">new</span> Properties();<br>        prop.setProperty(<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>        <span class="hljs-comment">// 设置异常映射</span><br>        exceptionResolver.setExceptionMappings(prop);<br>        <span class="hljs-comment">// 设置共享异常信息的键</span><br>        exceptionResolver.setExceptionAttribute(<span class="hljs-string">&quot;ex&quot;</span>);<br>        resolvers.add(exceptionResolver);<br>    &#125;<br><br>  <span class="hljs-comment">// thymeleaf</span><br>    <span class="hljs-comment">// 配置生成模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITemplateResolver <span class="hljs-title">templateResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        WebApplicationContext webApplicationContext = <br>          ContextLoader.getCurrentWebApplicationContext();<br>        <span class="hljs-comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数</span><br>      <span class="hljs-comment">// 可通过WebApplicationContext 的方法获得</span><br>        ServletContextTemplateResolver templateResolver = <span class="hljs-keyword">new</span> <br>          ServletContextTemplateResolver(webApplicationContext.getServletContext());<br>        templateResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>);<br>        templateResolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);<br>        templateResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        templateResolver.setTemplateMode(TemplateMode.HTML);<br>        <span class="hljs-keyword">return</span> templateResolver;<br>    &#125;<br><br>  <span class="hljs-comment">// thymeleaf</span><br>    <span class="hljs-comment">// 生成模板引擎并为模板引擎注入模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title">templateEngine</span><span class="hljs-params">(ITemplateResolver templateResolver)</span> </span>&#123;<br>        SpringTemplateEngine templateEngine = <span class="hljs-keyword">new</span> SpringTemplateEngine();<br>        templateEngine.setTemplateResolver(templateResolver);<br>        <span class="hljs-keyword">return</span> templateEngine;<br>    &#125;<br>  <br><span class="hljs-comment">// thyleaf</span><br>    <span class="hljs-comment">// 生成视图解析器并未解析器注入模板引擎</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title">viewResolver</span><span class="hljs-params">(SpringTemplateEngine templateEngine)</span> </span>&#123;<br>        ThymeleafViewResolver viewResolver = <span class="hljs-keyword">new</span> ThymeleafViewResolver();<br>        viewResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        viewResolver.setTemplateEngine(templateEngine);<br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringConfig"><a href="#SpringConfig" class="headerlink" title="SpringConfig"></a>SpringConfig</h2><p>初始化类 <em><strong>SpringConfig</strong></em>，代替 <em><strong>spring.xml</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br><span class="hljs-comment">// ssm整合之后，spring的配置信息写在此类中</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的组件解析"><a href="#SpringMVC的组件解析" class="headerlink" title="SpringMVC的组件解析"></a>SpringMVC的组件解析</h1><h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><blockquote><ol><li><p><strong>前端控制器：DispatcherServlet</strong></p><p>用户请求到达前端控制器，它就相当于 <em><strong>MVC</strong></em> 模式中的 <em><strong>C</strong></em>，<em><strong>DispatcherServlet</strong></em> 是整个流程控制的中心，由，它调用其它组件处理用户的请求，<em><strong>DispatcherServlet</strong></em> 的存在降低了组件之间的耦合性。</p><p>统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求。</p></li><li><p><strong>处理器映射器：HandlerMapping</strong></p><p><em><strong>HandlerMapping</strong></em> 负责根据用户请求找到 <em><strong>Handler</strong></em> 即处理器 Controller，SpringMVC 提供了不同的映射器实现不同的。映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p>根据请求的 <em><strong>url、method</strong></em> 等信息查找 <em><strong>Handler</strong></em>，即控制器方法。</p></li><li><p><strong>处理器适配器：HandlerAdapter</strong></p><p>通过 <em><strong>HandlerAdapter</strong></em> 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理。</p></li><li><p><strong>处理器：Handler</strong></p><p>在 <em><strong>DispatcherServlet</strong></em> 的控制下 <em><strong>Handler</strong></em> 对具体的用户请求进行处理。</p><p>它就是我们开发中要编写的具体业务控制器。由 <em><strong>DispatcherServlet</strong></em> 把用户请求转发到 <em><strong>Handler</strong></em>。由</p><p><em><strong>Handler</strong></em> 对具体的用户请求进行处理。</p><p>即控制器 <em><strong>Controller</strong></em>。</p></li><li><p><strong>视图解析器：View Resolver</strong></p><p><em><strong>View Resolver</strong></em> 负责将处理结果生成 <em><strong>View</strong></em> 视图，<em><strong>View Resolver</strong></em> 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 <em><strong>View</strong></em> 视图对象，最后对 <em><strong>View</strong></em> 进行渲染将处理结果通过页面展示给用户。（<em><strong>ThymeleafView、InternalResourceView、RedirectView</strong></em>）</p><p>即进行视图解析，得到相应的视图。</p></li><li><p><strong>视图：View</strong></p><p><em><strong>SpringMVC</strong></em> 框架提供了很多的 <em><strong>View</strong></em> 视图类型的支持，包括：<em><strong>jstlView、freemarkerView、pdfView</strong></em> 等。最常用的视图就是 <em><strong>jsp</strong></em>。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p><p>即将模型数据通过页面展示给用户。</p></li></ol></blockquote><h2 id="DispatchServlet"><a href="#DispatchServlet" class="headerlink" title="DispatchServlet"></a>DispatchServlet</h2><p><em><strong>：中央控制器</strong></em></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/img005.png"  style="zoom:70%;" /><h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p><em><strong><u>源码 to do</u></strong></em></p><h3 id="服务过程"><a href="#服务过程" class="headerlink" title="服务过程"></a>服务过程</h3><p><em><strong><u>源码 to do</u></strong></em></p><h3 id="调用组件处理请求"><a href="#调用组件处理请求" class="headerlink" title="调用组件处理请求"></a>调用组件处理请求</h3><p><em><strong><u>源码 to do</u></strong></em></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-09-19%2010.23.18.png" style="zoom:50%;" /><p><strong><u>总结流程</u></strong></p><blockquote><ol><li><p>用户向服务器发送请求，请求被前端控制器 <em><strong>DispatcherServlet</strong></em> 捕获；</p></li><li><p><em><strong>DispatcherServlet</strong></em> 收到请求，对请求 <em><strong>URL</strong></em> 进行解析，得到请求资源标志符（<em><strong>URL</strong></em>）， 调用 <em><strong>HandlerMapping</strong></em> 处理器映射器；</p><ol><li><p>若当前映射不存在（<em><strong>HandlerMapping</strong></em>）；</p><ol><li><p>判断是否配置默认 <em><strong>Servlet</strong></em> 处理资源资源： ***&lt;default-servlet-handler&gt;***。</p></li><li><p>若未配置，控制台显示映射无法找到，客户端展示 <em><strong>404</strong></em> 页面错误；</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/img007.png" alt="img007" style="zoom:50%;" /></li><li><p>若已经配置，但是无法找到访问资源，客户端展示 <em><strong>404</strong></em> 页面错误。</p></li></ol></li><li><p>若当前映射存在。</p><ol><li><p>根据该 <em><strong>URI</strong></em>，调用 <em><strong>HandlerMapping</strong></em> 获得该 <em><strong>Handler</strong></em> 配置的所有相关的对象（包括 <em><strong>Handler</strong></em> 对象以及 <em><strong>Handler</strong></em> 对象对应的拦截器），最后以 <em><strong>HandlerExecutionChain</strong></em> 执行链对象的形式返回；</p></li><li><p><em><strong>DispatcherServlet</strong></em> 根据获得的 <em><strong>Handler</strong></em>，选择一个合适的 <em><strong>HandlerAdapter</strong></em>；</p></li><li><p>如果成功获得 <em><strong>HandlerAdapter</strong></em>，此时将开始执行拦截器的 <em><strong>preHandler</strong></em>方法；</p></li><li><p>提取 <em><strong>Request</strong></em> 中的模型数据，填充 <em><strong>Handler</strong></em> 入参，开始执行 <em><strong>Handler</strong></em> 方法，即 <em><strong>Controller</strong></em> 方法，处理请求。在填充 <em><strong>Handler</strong></em> 的入参过程中，根据你的配置，<em><strong>Spring</strong></em> 将帮你做一些额外的工作：</p><ol><li><p><em><strong>HttpMessageConveter</strong></em></p><p>将请求消息（如 <em><strong>Json、xml</strong></em> 等数据）转换成一个对象，将对象转换为指定的响应信息。</p></li><li><p>数据转换</p><p>对请求消息进行数据转换。</p></li><li><p>数据格式化</p><p>对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p></li><li><p>数据验证</p><p>验证数据的有效性（长度、格式等）。</p></li></ol></li><li><p><em><strong>Handler</strong></em> 执行完成后，向 <em><strong>DispatcherServlet</strong></em> 返回一个 <em><strong>ModelAndView</strong></em> 对象；</p></li><li><p>此时将开始执行拦截器的 <em><strong>postHandle</strong></em> 方法；</p></li><li><p>根据返回的 <em><strong>ModelAndView</strong></em> </p><ol><li><p>若存在异常，则执行 <em><strong>HandlerExceptionResolver</strong></em> 进行异常处理；</p></li><li><p>否则，选择一个适合的 <em><strong>ViewResolver</strong></em> 进行视图解析，根据 <em><strong>Model</strong></em> 和 <em><strong>View</strong></em>，来渲染视图。</p></li></ol></li><li><p>渲染视图完毕执行拦截器的 <em><strong>afterCompletion</strong></em> 方法；</p></li><li><p>将渲染结果返回给客户端。</p></li></ol></li></ol></li></ol></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1Ry4y1574R?p=1">尚硅谷-杨博超</a></li><li><a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?spm_id_from=333.999.0.0">黑马程序员</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>Spring家族</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>springmvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
