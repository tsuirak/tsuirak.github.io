<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2021/10/27/nginx/"/>
    <url>/2021/10/27/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><em><strong>Nginx</strong></em> 是高性能的 <em><strong>HTTP</strong></em> 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验，有报告表明能支持高达 50,000 个并发连接数。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><strong>正向代理</strong></p><p><em><strong>Nginx</strong></em> 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 <em><strong>Internet</strong></em> 想象成一个巨大的资源库，则局域网中的客户端要访问 <em><strong>Internet</strong></em>，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p><p><u>需要在客户端配置代理服务器进行指定网站访问</u>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.29.54.png" style="zoom:50%;" /><p><strong>反向代理</strong></p><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，<u>暴露的是代理服务器地址，隐藏了真实服务器 <em><strong>IP</strong></em> 地址</u>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.35.09.png" style="zoom:50%;" /><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>单一模式</strong></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.40.11.png" style="zoom:50%;" /><p><strong>负载均衡</strong></p><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.45.55.png" style="zoom:50%;" /><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 16.49.18.png" style="zoom:50%;" /><h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><p>官网：<a href="http://nginx.org/">http://nginx.org/</a></p><blockquote><ol><li>需要安装 <em><strong>gcc-c++</strong></em> 编译器</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> gcc-c++<br>yum <span class="hljs-keyword">install</span> -y openssl openssl-devel<br></code></pre></td></tr></table></figure><ol start="2"><li>安装 <em><strong>pcre</strong></em> 包</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y pcre pcre-devel<br></code></pre></td></tr></table></figure><ol start="3"><li>安装 <em><strong>zlib</strong></em> 包</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">yum install -y <span class="hljs-literal">zlib</span> <span class="hljs-literal">zlib</span>-devel<br></code></pre></td></tr></table></figure><ol start="4"><li>在 <em><strong>/opt/</strong></em>  下载 <em><strong>nginx</strong></em></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://nginx.org/download/nginx-1.19.9.tar.gz<br></code></pre></td></tr></table></figure><ol start="5"><li>解压并进入 <em><strong>nginx</strong></em> 目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf nginx-1.19.9.tar.gz<br><span class="hljs-built_in">cd</span> nginx-1.19.9<br></code></pre></td></tr></table></figure><ol start="6"><li>使用 <em><strong>nginx</strong></em> 默认配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure<br></code></pre></td></tr></table></figure><ol start="7"><li>编译安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>默认安装路径：<code>/usr/local/nginx</code></p><p>启动：<code>cd /usr/local/nginx/sbin</code></p><p>默认启动脚本：<code>./nginx</code></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 17.02.59.png" style="zoom:50%;" /><p>成功启动后可以进行访问：<code>172.16.88.168:80</code>（需要关闭防火墙）</p><p>默认端口：80</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/nginx/sbin <span class="hljs-comment"># 默认安装路径</span><br><br>./nginx -v <span class="hljs-comment"># 查看 nginx 版本号 </span><br><br>./nginx <span class="hljs-comment"># 启动 nginx</span><br><br>./nginx -s stop <span class="hljs-comment"># 停止 nginx </span><br><br>./nginx -s reload <span class="hljs-comment"># 重新加载 nginx </span><br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><em><strong>nginx.conf</strong></em></p><p>默认路径：***/usr/local/nginx/conf/nginx.conf***</p><blockquote><p><em><strong>全局块</strong></em></p><p>主要包括配置运行 <em><strong>Nginx</strong></em> 服务器的用户（组）、允许生成的 <em><strong>worker process</strong></em> 数，进程 <em><strong>PID</strong></em> 存放路径、日志存放路径和类型以及配置文件的引入等。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 21.47.03.png" style="zoom:50%;" /><p><em><strong>events块</strong></em></p><p><em><strong>events</strong></em> 块涉及的指令主要影响 <em><strong>Nginx</strong></em> 服务器与用户的网络连接，常用的设置包括是否开启对多 <em><strong>work process</strong></em> 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 <em><strong>word process</strong></em> 可以同时支持的最大连接数等。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 21.48.11.png" style="zoom:50%;" /><p><em><strong>http块</strong></em></p><p>这算是 <em><strong>Nginx</strong></em> 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：<em><strong>http</strong></em> 块也可以包括 <em><strong>http</strong></em> 全局块、<em><strong>server</strong></em> 块。</p><ol><li><p><em><strong>http 全局块</strong></em></p><p><em><strong>http</strong></em> 全局块配置的指令包括文件引入、<em><strong>MIME-TYPE</strong></em> 定义、日志自定义、连接超时时间、单链接请求数上限等。</p></li><li><p><em><strong>server块</strong></em></p><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。</p><p>每个 <em><strong>http</strong></em> 块可以包括多个 <em><strong>server</strong></em> 块，而每个 <em><strong>server</strong></em> 块就相当于一个虚拟主机。 而每个 <em><strong>server</strong></em> 块也分为全局 <em><strong>server</strong></em> 块，以及可以同时包含多个 <em><strong>locaton</strong></em> 块。</p><ol><li><p><em><strong>全局 server 块</strong></em></p><p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p></li><li><p><em><strong>location 块</strong></em></p><p>一个 <em><strong>server</strong></em> 块可以配置多个 <em><strong>location</strong></em> 块。</p><p>这块的主要作用是基于 <em><strong>Nginx</strong></em> 服务器接收到的请求字符串（例如 <em><strong>server_name/uri-string</strong></em>），对虚拟主机名称（也可以是 <em><strong>IP</strong></em> 别名）之外的字符串（例如 前面的 <em><strong>/uri-string</strong></em>）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ol></li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 21.48.47.png" style="zoom:50%;" /></blockquote><h2 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h2><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">实现效果：使用 nginx 进行反向代理，访问 www<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.com</span> 直接跳转到 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>访问的流程：</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 23.55.12.png" alt="" style="zoom:50%;" /><p>如何启动 <em><strong>tomcat</strong></em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> tomcat安装路径bin目录<span class="hljs-regexp">//</span> 默认端口<span class="hljs-number">8080</span>./startup.sh<br></code></pre></td></tr></table></figure><ol><li>本地 <em><strong>hosts</strong></em> 文件进行域名和 <em><strong>ip</strong></em> 对应配置</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 最后一行加上# 虚拟机对应的ip172<span class="hljs-number">.16</span><span class="hljs-number">.88</span><span class="hljs-number">.168</span> www.test.com<br></code></pre></td></tr></table></figure><ol start="2"><li>在 <em><strong>nginx</strong></em> 进行请求转发的配置（反向代理配置）</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 23.54.20.png" alt="" style="zoom:50%;" /><ol start="3"><li>启动 <em><strong>nginx</strong></em></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 默认路径 <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/./</span>nginx -c <span class="hljs-regexp">/opt/</span>etc/nginx.conf <span class="hljs-comment"># 配置文件的路径</span><br></code></pre></td></tr></table></figure><p>最终：访问 <code>wwww.test.com</code> 跳转到 <em><strong>tomcat</strong></em> 成功启动页面。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 23.56.21.png" style="zoom:50%;" /><hr><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中 nginx 监听端口为 <span class="hljs-number">9001</span>访问 http:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>:<span class="hljs-number">9001</span><span class="hljs-regexp">/edu/</span> 直接跳转到 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>访问 http:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>:<span class="hljs-number">9001</span><span class="hljs-regexp">/vod/</span> 直接跳转到 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><ol><li><p>准备两个 <em><strong>tomcat</strong></em> 服务器（略）</p></li><li><p>配置 <em><strong>nginx.conf</strong></em></p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;        listen       <span class="hljs-number">9001</span>;        server_name  <span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>;        location ~ <span class="hljs-regexp">/edu/</span> &#123;            proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>;        &#125;        location ~ <span class="hljs-regexp">/vod/</span> &#123;            proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8081</span>;        &#125; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a><em>proxy_pass</em></h3><blockquote><p>格式： <em><strong>proxy_pass URL</strong></em></p><p>URL包含：传输协议、主机名、<em><strong>uri</strong></em></p></blockquote><p><em><strong>url</strong></em> 的 / 问题</p><blockquote><p>在 <em><strong>nginx</strong></em> 中配置 <em><strong>proxy_pass</strong></em> 时，当在后面的 <em><strong>url</strong></em> 加上了/，相当于是绝对根路径，则 <em><strong>nginx</strong></em> 不会把 <em><strong>location</strong></em> 中匹配的路径部分代理；</p><p>如果没有 /，则会把匹配的路径部分也给代理。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">假设 server_name:192.168.1.10请求:http://192.168.1.10/a/a.html示例1：location /a/&#123;    proxy_pass http://192.168.1.10;    ...&#125;结果1：http://192.168.1.10/a/a.html示例2：location /a/&#123;    proxy_pass http://192.168.1.10/;    ...&#125;结果2：http://192.168.1.10/a.html示例3：location /a/&#123;    proxy_pass http://192.168.1.10/nanase;    ...&#125;结果3：http://192.168.1.10/nanasea.html示例4：location /a/&#123;    proxy_pass http://192.168.1.10/nanase/;    ...&#125;结果4：http://192.168.1.10/nanase/a.html<br></code></pre></td></tr></table></figure><p><strong><u>为了方便记忆和规范配置，建议所有的 <em>proxy_pass</em> 后的 <em>url</em> 都以 / 结尾。</u></strong></p><h3 id="location"><a href="#location" class="headerlink" title="location"></a><em>location</em></h3><p>该指令用于匹配 <em><strong>URL</strong></em>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> [ = | <span class="hljs-regexp">~ |</span> <span class="hljs-regexp">~* |</span><span class="hljs-regexp"> ^~</span> ] uri &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>=</code> </p><p>用于不含正则表达式的 <em><strong>uri</strong></em> 前，要求请求字符串与 <em><strong>uri</strong></em> 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p><p><code>~</code></p><p>用于表示 <em><strong>uri</strong></em> 包含正则表达式，并且区分大小写。</p><p><code>~*</code></p><p>用于表示 <em><strong>uri</strong></em> 包含正则表达式，并且不区分大小写。</p><p><code>^~</code></p><p>用于不含正则表达式的 <em><strong>uri</strong></em> ，要求 <em><strong>Nginx</strong></em> 服务器找到标识 <em><strong>uri</strong></em> 和请求 符串匹配度最高的 <em><strong>location</strong></em> 后，立即使用此 <em><strong>location</strong></em> 处理请求，而不再使用 <em><strong>location</strong></em> 块中的正则 <em><strong>uri</strong></em> 和请求字符串做匹配。</p></blockquote><p><strong><u><em>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</em></u></strong>                 </p><p>​                                                                       </p><h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上面。即将原先请求集中到单个服务器上转化为将请求分发到多个服务器上，将负载分发到不同的服务器，即负载均衡。</p><h4 id="案例-1-1"><a href="#案例-1-1" class="headerlink" title="案例 1"></a>案例 1</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">实现效果：浏览器地址栏输入地址 http:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span><span class="hljs-regexp">/edu/</span>a.html，负载均衡效果，平均分担 <span class="hljs-number">8080</span> 和 <span class="hljs-number">8081</span> 端口中。<br></code></pre></td></tr></table></figure><ol><li>准备两个 <em><strong>tomcat</strong></em> 服务器（略）</li><li>配置 <em><strong>nginx.conf</strong></em> 文件</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span> &#123;...upsteam myserver &#123;ip_hash;server <span class="hljs-number">172.16.88.168:8080</span> weight=<span class="hljs-number">1</span>;server <span class="hljs-number">172.16.88.168:8081</span> weight=<span class="hljs-number">1</span>;&#125;server &#123;        listen       <span class="hljs-number">80</span>;        server_name  <span class="hljs-number">172.16.88.168</span>;        location / &#123;            proxy_pass http://myserver;            root html;            index index.html index.htm;        &#125; ... &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><ul><li><p><em><strong>轮询</strong></em>（默认）<br> 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 <em><strong>down</strong></em> 掉，能自动剔除。</p></li><li><p><em><strong>weight</strong></em><br> <em><strong>weight</strong></em> 代表权重默认为 1，权重越高被分配的客户端越多。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">upstream server_pool &#123;<span class="hljs-built_in">server </span>192.168.5.21 <span class="hljs-attribute">weight</span>=10; <span class="hljs-built_in">server </span>192.168.5.22 <span class="hljs-attribute">weight</span>=10; &#125;<br></code></pre></td></tr></table></figure></li><li><p><em><strong>ip_hash</strong></em><br> 每个请求按访问 <em><strong>ip</strong></em> 的 <em><strong>hash</strong></em> 结果分配，这样每个访客固定访问一个后端服务器。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">upstream server_pool &#123;<span class="hljs-attribute">ip_hash;server 192.168.5.21</span>:80; <span class="hljs-attribute">server 192.168.5.22</span>:80; &#125;<br></code></pre></td></tr></table></figure></li><li><p><em><strong>fair</strong></em>（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">upstream</span> server_pool &#123; server <span class="hljs-number">192.168.5.21:80</span>; server <span class="hljs-number">192.168.5.22:80</span>; fair;&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h2><p><em><strong>Nginx</strong></em> 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。</p><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。</p><p>另外一种方法就是动态跟静态文件混合在一起发布，通过 <em><strong>nginx</strong></em> 来分开。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.18.44.png" style="zoom:50%;" /><h4 id="案例-1-2"><a href="#案例-1-2" class="headerlink" title="案例 1"></a>案例 1</h4><ol><li>在 <em><strong>linux</strong></em> 系统中准备静态资源，用于进行访问</li><li>配置 <em><strong>nginx</strong></em> 文件</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">server &#123;        listen       <span class="hljs-number">80</span>;        server_name  <span class="hljs-number">172.16</span>.<span class="hljs-number">88.168</span>;        location <span class="hljs-regexp">/html/</span> &#123;        root <span class="hljs-regexp">/data/</span>;        index index.html index.htm;        # 访问 <span class="hljs-regexp">/data/</span>html<span class="hljs-regexp">/.*html        &#125;        location /im</span>age<span class="hljs-regexp">/ &#123;        root /</span>data/;        autoindex on; # 列出文件目录        &#125; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="高可用集群"><a href="#高可用集群" class="headerlink" title="高可用集群"></a>高可用集群</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.21.39.png" alt="截屏2021-10-27 14.21.39" style="zoom:50%;" /><p>即主服务器宕机，启动备用服务器。</p><h4 id="案例-1-3"><a href="#案例-1-3" class="headerlink" title="案例 1"></a>案例 1</h4><p><em><strong>keepalive + nginx</strong></em></p><p><strong>高可用集群（主从模式）</strong></p><ol><li><p>准备两台服务器</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">服务器ip：<span class="hljs-number">192.168.17.128</span><span class="hljs-number">192.168.17.131</span><br></code></pre></td></tr></table></figure></li><li><p>两台服务器安装 <em><strong>keepalive</strong></em> 和 <em><strong>nginx</strong></em> （略）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> keepalive-y<br></code></pre></td></tr></table></figure></li><li><p>完成高可用配置（主从模式）</p><p>在 <code>/usr/local/src/</code> 添加检测脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bashA=`ps -C nginx –no-header |wc -l` if [ $A -eq 0 ];then/usr/local/nginx/sbin/nginxsleep 2if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then        killall keepalived    fifi</span><br></code></pre></td></tr></table></figure><p>配置主服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主要修改 keepalive 配置文件# /etc/keepalived/keepalived.conf# 主和备服务器修改不同地方# 全局配置global_defs &#123;notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc&#125;notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.17.129smtp_connect_timeout 30router_id LVS_DEVEL # 访问主机服务器名字&#125;# 脚本配置vrrp_script chk_http_port &#123; script &quot;/usr/local/src/nginx_check.sh&quot; # 脚本interval 2 # 检测脚本执行的间隔weight 2 # 设置当前服务器的权重&#125;# 虚拟ip配置vrrp_instance VI_1 &#123; state MASTER # 主服务器：MASTER 备份服务器：BACKUP interface ens33 # 网卡virtual_router_id 51 # 主备机的id必须相同priority 100 # 优先级；主机值较大，备份机值较小 advert_int 1 # 时间间隔检测# 权限authentication &#123; auth_type PASSauth_pass 1111 &#125;# 虚拟ipvirtual_ipaddress &#123;192.168.17.50 # VRRP H 虚拟地址&#125;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>启动 <em><strong>nginx</strong></em> 和 <em><strong>keepalived</strong></em> 服务</p></li></ol><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="master-amp-worker"><a href="#master-amp-worker" class="headerlink" title="master&amp;worker"></a>master&amp;worker</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.49.04.png" style="zoom:50%;" /><h2 id="worker如何工作"><a href="#worker如何工作" class="headerlink" title="worker如何工作"></a>worker如何工作</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 14.59.12.png" style="zoom:50%;" /><h2 id="一个master多个worker"><a href="#一个master多个worker" class="headerlink" title="一个master多个worker"></a>一个master多个worker</h2><ul><li>可以使用 <em><strong>nginx –s reload</strong></em> 热部署，利用 <em><strong>nginx</strong></em> 进行热部署操作；</li><li>每个 <em><strong>woker</strong></em> 是独立的进程，如果有其中的一个 <em><strong>woker</strong></em> 出现问题，其他 <em><strong>woker</strong></em> 独立的， 继续进行争抢，实现请求过程，不会造成服务中断。</li></ul><h2 id="worker的数量"><a href="#worker的数量" class="headerlink" title="worker的数量"></a>worker的数量</h2><p><em><strong>nginx</strong></em> 类似 <em><strong>redis</strong></em> 都采用 <em><strong>io</strong></em> 多路复用机制，每个 <em><strong>worker</strong></em> 都是一个独立的进程。</p><p>即 <em><strong>worker</strong></em> 数量和服务器的 <em><strong>cpu</strong></em> 数量相等最合适。</p><h2 id="连接数worker-connection"><a href="#连接数worker-connection" class="headerlink" title="连接数worker_connection"></a>连接数worker_connection</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">第一个：发送请求，占用了 woker 的几个连接数? 答案:<span class="hljs-number"> 2 </span>或者<span class="hljs-number"> 4 </span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">第二个：nginx 有一个 master，有 <span class="hljs-number">4</span> 个 woker，每个 woker 支持最大的连接数 <span class="hljs-number">1024</span>，支持的最大并发数是多少?worker支持的最大连接数：<span class="hljs-number">4</span> * <span class="hljs-number">1024</span>普通的静态访问最大并发数是：worker_connections * worker_processes <span class="hljs-regexp">/ 21024 * 4 /</span> <span class="hljs-number">2</span>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是：worker_connections * worker_processes <span class="hljs-regexp">/ 41024 * 4 /</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1zJ411w7SV?from=search&seid=5693495616515059218&spm_id_from=333.337.0.0">尚硅谷-王老师</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>服务器软件</category>
      
      <category>Web服务器</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2021/08/25/java-thread/"/>
    <url>/2021/08/25/java-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li><p>进程是运行的程序。进程是程序的一次执行过程。操作系统会为进程分配内存空间；</p></li><li><p>动态过程：有自身的产生、存在和存亡的过程。</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>线程是由进程创建的，是进程的一个实体；</li><li>一个进程可以拥有多个线程。</li></ul><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>同一时刻，只允许执行一个线程。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>同一时刻，可以允许执行多个线程。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p class="note note-primary">重要</p><p>同一个时刻，多个任务交替执行。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 08.54.41.png" alt="截屏2021-09-16 08.54.41" style="zoom:50%;" /><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p class="note note-primary">重要</p><p>同一个时刻，多个任务同时执行。多核 CPU 可以实现并行。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 08.54.55.png" style="zoom:50%;" /><h1 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a><u>线程使用</u></h1><p class="note note-primary">重要</p><blockquote><p>创建线程的两种方法</p><ul><li>基础 Thread 类，重写 run 方法；</li><li>实现 Runnable 接口，重写 run 方法。</li></ul></blockquote><p><strong>Diagram关系</strong></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 09.08.04.png"  style="zoom:50%;" /><p><strong>案例1： 继承Thread</strong></p><ol><li><p>编程一个线程，该线程每隔1秒在控制台输出文字 “Hello”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建 Cat 对象当作线程使用</span><br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br>        <span class="hljs-comment">// 启动线程</span><br>        cat.start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *  1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span><br><span class="hljs-comment"> *  2. 重写 run 方法，写上自己的业务代码</span><br><span class="hljs-comment"> *  3. run Thread 类 实现了 Runnable 接口的 run 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重写 run 方法，写自己的逻辑业务</span><br>        <span class="hljs-comment">// 调用 start 方法，会执行一次 run 方法</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对上题进行改进，当输出100次 “Hello” 后，停止输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建 Cat 对象当作线程使用</span><br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br>        <span class="hljs-comment">// 启动线程</span><br>        cat.start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *  1. 当一个类继承了 Thread 类， 该类就可以当做线程使用</span><br><span class="hljs-comment"> *  2. 重写 run 方法，写上自己的业务代码</span><br><span class="hljs-comment"> *  3. run Thread 类 实现了 Runnable 接口的 run 方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重写 run 方法，写自己的逻辑业务</span><br>        <span class="hljs-comment">// 调用 start 方法，会执行一次 run 方法</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            time++;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(time == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">break</span>;  <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>画出程序的执行图。</p></li></ol><ul><li>当主线程（main 线程）启动一个子线程 Thread-0，主线程不会阻塞，会继续执行，此时主线程和子线程交替进行；</li><li>主线程结束后，若子线程还在运行，整个进程并不会结束。</li></ul><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 09.37.42.png"  style="zoom:50%;" /><p><strong>案例2：实现Runnable</strong></p><blockquote><p>Java是单继承的；</p><p>通过实现 Runnable接口来创建线程。</p></blockquote><p>编程一个线程，该线程每隔1秒在控制台输出文字 “Hello”。当输出10次后，自动退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread</span>  </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// 无法直接调用 start 方法</span><br>        <span class="hljs-comment">// 创建 Thread 对象，将 dog 对象放入 Thread</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(dog);<br>        thread.start();;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + ++count + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例3：多线程</strong></p><p>创建两个线程，一个线程每隔1秒输出 “Hello World”，10次后退出；另一个线程每隔1秒输出 “hi”，5次后退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tsuiraku.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Hello hello = <span class="hljs-keyword">new</span> Hello();<br>        Hi hi = <span class="hljs-keyword">new</span> Hi();<br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(hello);<br>        Thread thread2 = <span class="hljs-keyword">new</span> Thread(hi);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + (++count) + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Hi&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + (++count) + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>案例4：多线程模拟售票系统</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tsuiraku.thread.demo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Description</span>:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        SellTicket01 s1 = new SellTicket01();</span><br><span class="hljs-comment">//        SellTicket01 s2 = new SellTicket01();</span><br><span class="hljs-comment">//        SellTicket01 s3 = new SellTicket01();</span><br><span class="hljs-comment">//        s1.start();</span><br><span class="hljs-comment">//        s2.start();</span><br><span class="hljs-comment">//        s3.start();</span><br><br>        SellTicket02 s = <span class="hljs-keyword">new</span> SellTicket02();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(s);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 Thread 方式</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 休眠50ms</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>            + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 Runnable 方式</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 休眠50ms</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>                    + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：出现 ticketNum 值为负数的情况。因为三个线程同时访问修改 tiketNum。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 10.51.12.png"  style="zoom:50%;" /><p>如何解决？<a href="#Synchronized">Synchronized</a></p><p><u><strong>源码</strong></u></p><p><code>thread.start()</code></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 09.48.18.png"  style="zoom:50%;" /><p>**<u>start0</u>**：<code>start0</code> 是一个 native 方法，由 JVM 调用。<code>start()</code> 方法调用 <code>start0()</code> 方法后，该线程并不一定马上执行，只是讲线程变成了可运行状态。具体执行时间，由 CPU 统一调度。</p><p><strong>思考</strong></p><ul><li><p><code>thread.start()</code> 和 <code>thread.run()</code>；</p><p>如果直接执行 <code>thread.run()</code> 方法，那么实际上是主线程在执行，并不会真正启动一个线程，并且程序会阻塞。而使用 <code>thread.start()</code> 方法，主线程会开启一个子线程，程序并不会阻塞，而是主线程和子线程交替进行。</p></li></ul><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><blockquote><p>当线程完成任务后，自动退出；</p><p>通过使用变量来控制 run 方法退出的方式停止线程，即通知方式。</p></blockquote><p><strong>案例</strong></p><p>启动一个线程 t，要求在 main 线程中停止线程 t。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        T t = <span class="hljs-keyword">new</span> T();<br>        t.start();<br><br>        <span class="hljs-comment">// 希望 main 线程控制 t 线程的终止，即修改 loop</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>        <br>        t.setLoop(<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> loop = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (loop) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;T运行中...&quot;</span>);;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoop</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loop)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loop = loop;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 11.07.12.png"  style="zoom:50%;" /><h1 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h1><blockquote><p>setName；// 设置线程名称</p><p>getName；// 获取线程名称</p><p>start；// 执行线程，JVM调用底层 start0</p><p>run；// 调用线程对象 run 方法</p><p>setPriority；// 设置线程优先级</p><p>getPriority；// 获取线程优先级</p><p>sleep；// 线程休眠</p><p>interrupt；// 线程中断，但并没有真正结束线程。一般用于中断正在休眠的线程。</p><p>yield；// 线程的礼让。让出 CPU，让其他线程执行，但礼让的时间不确定，所以也不一定会成功。</p><p>join。//线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程的所有任务。</p></blockquote><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>实际上并没有让线程停止运行。一般用于唤醒正在休眠的线程。</p><h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><ul><li>yield</li></ul><p>线程主动礼让 CPU。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 13.48.42.png"  style="zoom:50%;" /><ul><li>join</li></ul><p>主动放弃 CPU，让其他线程插队。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 15.36.56.png"  style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadMethodExercise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> T());<br>    <span class="hljs-comment">// 创建子线程 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>      System.out.println(<span class="hljs-string">&quot;hi &quot;</span> + i);<br>      <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// 说明主线程输出了 5 次 hi</span><br>        t.start(); <span class="hljs-comment">// 启动子线程 输出 hello...</span><br>        t.join(); <span class="hljs-comment">// 立即将 t 子线程，插入到 main 线程，让 t 先执行 </span><br>      &#125;<br>        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//输出一次 hi, 让 main 线程也休眠 1s </span><br>    &#125;<br>  &#125; <br>&#125;<br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + (++count)); <br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace(); &#125;<br>      <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123; <br>        <span class="hljs-keyword">break</span>;<br>       &#125; <br>    &#125;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><u><strong>源码</strong></u></p><p>优先级</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-09-16 11.18.02.png"  style="zoom:50%;" /><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>也称为工作线程。当线程的任务执行完或者通知方式结束。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>一般是为工作线程服务的，当所有的用户线程结束后，守护线程自动结束。常见的守护线程：垃圾回收机制。</p><p>如何将一个线程设置为守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        T t = <span class="hljs-keyword">new</span> T();<br>        t.setDaemon(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 设置守护线程</span><br>        t.start();<br><br>        <span class="hljs-comment">// 希望当 main 线程结束后，希望子线程 t 自动终止</span><br>      <span class="hljs-comment">// 将子线程设置为守护线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;T 运行中...&quot;</span>);;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p class="note note-primary">重要</p><h3 id="七状态转化"><a href="#七状态转化" class="headerlink" title="七状态转化"></a><u>七状态转化</u></h3><blockquote><p><strong>新建状态（New）</strong></p><p>当用 new 操作符创建一个线程后， 此时线程处在新建状态。 当一个线程处于新建状态时，线程中的任务代码还没开始运行。</p><p><strong>就绪状态（Runnable）</strong></p><p>也被称为“可执行状态”。一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的 <code>start()</code> 方法。当调用了线程对象的 <code>start()</code> 方法即启动了线程，此时线程就处于就绪状态。</p><p>处于就绪状态的线程并不一定立即运行 <code>run()</code> 方法，线程还必须同其他就绪线程竞争 CPU，只有获得 CPU 使用权才可以运行线程。比如在单核心 CPU 的计算机系统中，不可能同时运行多个线程，一个时刻只能有一个线程处于运行状态。对与多个处于就绪状态的线程是由 Java 运行时系统的线程调度程序（thread scheduler）来调度执行。</p><p>除了调用 <code>start()</code> 方法后让线程变成就绪状态，一个线程阻塞状态结束后也可以变成就绪状态，或者从运行状态变化到就绪状态。</p><p><strong>运行状态（Running）</strong></p><p>线程获取到 CPU 使用权进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。真正开始执行 <code>run()</code> 方法的内容。</p><p><strong>阻塞状态（Blocked）</strong></p><p>线程在获取锁失败时（因为锁被其它线程抢占），它会被加入锁的同步阻塞队列，然后线程进入阻塞状态（Blocked）。处于阻塞状态（Blocked）的线程放弃 CPU 使用权，暂时停止运行。待其它线程释放锁之后，阻塞状态（Blocked）的线程将在次参与锁的竞争，如果竞争锁成功，线程将进入就绪状态（Runnable）。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 进入阻塞状态等待进入同步代码块的锁# 离开活的锁<br></code></pre></td></tr></table></figure><p><strong>等待状态（WAITING）</strong></p><p>或者叫条件等待状态，当线程的运行条件不满足时，通过锁的条件等待机制（调用锁对象的 <code>wait()</code> 或显示锁条件对象的 <code>await()</code> 方法）让线程进入等待状态（WAITING）。处于等待状态的线程将不会被 CPU 执行，除非线程的运行条件得到满足后，其可被其他线程唤醒，进入阻塞状态（Blocked）。调用不带超时的 Thread.join()方法也会进入等待状态。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"># 进入等待状态<span class="hljs-selector-tag">o</span><span class="hljs-selector-class">.wait</span>(time)<span class="hljs-selector-tag">t</span><span class="hljs-selector-class">.join</span>()<span class="hljs-selector-tag">LockSupport</span><span class="hljs-selector-class">.park</span>()# 离开<span class="hljs-selector-tag">o</span><span class="hljs-selector-class">.notify</span>()<span class="hljs-selector-tag">o</span><span class="hljs-selector-class">.notifyAll</span>()<span class="hljs-selector-tag">LockSupport</span><span class="hljs-selector-class">.unpark</span>()<br></code></pre></td></tr></table></figure><p><strong>限时等待状态（TIMED_WAITING）</strong></p><p>限时等待是等待状态的一种特例，线程在等待时我们将设定等待超时时间，如超过了我们设定的等待时间，等待线程将自动唤醒进入阻塞状态（Blocked）或就绪状态（Runnable)）。在调用 <code>Thread.sleep()</code> 方法，带有超时设定的 <code>Object.wait()</code> 方法，带有超时设定的 <code>Thread.join()</code> 方法等，线程会进入限时等待状态（TIMED_WAITING）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 进入限时等待状态<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(time)o.wait(time)t.join(time)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LockSupport</span>.</span></span>park<span class="hljs-constructor">Nanos()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LockSupport</span>.</span></span>park<span class="hljs-constructor">Until()</span># 离开时间结束<br></code></pre></td></tr></table></figure><p><strong>死亡状态（TERMINATED）</strong></p><p>线程执行完了或者因异常退出了 `run() 方法，该线程结束生命周期。</p></blockquote><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/1539204-20190625104746568-573625770-20210916175419041.png"></p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a><u>Synchronized</u></h1><p class="note note-primary">重要</p><blockquote><p>线程同步机制，同一时刻，最多有一个线程访问某个内存地址，直到该线程完成操作，其他线程才能对这个内存地址进行操作，以保证数据的完整性。</p></blockquote><blockquote><p><strong><u>Synchronized</u></strong></p><ol><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123; <span class="hljs-comment">// 得到对象的锁，才能操作同步代码  // 需要被同步的代码&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>放在方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span> <span class="hljs-params">(String name)</span> </span>&#123;  <span class="hljs-comment">// 需要被同步的代码&#125;</span><br></code></pre></td></tr></table></figure></li></ol></blockquote><p>解决：售票问题的同步问题</p><ul><li><p>代码块加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        SellTicket03 s = <span class="hljs-keyword">new</span> SellTicket03();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(s);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loop = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>      <span class="hljs-keyword">while</span>(loop) &#123;<br>        sell();<br>&#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 代码块上加锁</span><br>  <span class="hljs-comment">// 锁加在 this 对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 同步方法，同一时刻，只能有一个线程来执行 sell 方法</span><br>      <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>          System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>          loop = <span class="hljs-keyword">false</span>;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 休眠50ms</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>                           + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>      &#125;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法上加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Author</span>: tsuiraku</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        SellTicket03 s = <span class="hljs-keyword">new</span> SellTicket03();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(s);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(s);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTicket03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticketNum = <span class="hljs-number">100</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loop = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>      <span class="hljs-keyword">while</span>(loop) &#123;<br>        sell();<br>&#125;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 方法上加锁</span><br>  <span class="hljs-comment">// public synchronized void sell() 同步方法</span><br>  <span class="hljs-comment">// 锁加在 this 对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 同步方法，同一时刻，只能有一个线程来执行 sell 方法</span><br>      <span class="hljs-keyword">if</span>(ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>        loop = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 休眠50ms</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;窗口&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;售出了一张票&quot;</span><br>                         + <span class="hljs-string">&quot;;剩余票数 = &quot;</span> + (--ticketNum));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><u>互斥锁</u></h1><p class="note note-primary">重要</p><blockquote><p>作用是保证共享数据的完整性；</p><p>每个对象都对应于一个可称为 “互斥锁” 的标记，这个标记用于保证在同一时刻，只能有一个线程访问该对象；</p><p>关键字 synchronized 与对象互斥锁联系，当某个对象用 synchronized 修饰时，表面该对象任一时刻都只能由一个线程访问；</p><p>同步的局限性：导致程序的执行效率要降低；</p><p>同步方法（非静态）的锁可以是 this，也可以是其他对象（要求是同一个对象）；</p><p>同步方法（静态的）的锁为当前类本身，当前类.class。</p></blockquote><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>模拟死锁的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock_</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//模拟死锁现象</span><br>    DeadLockDemo A = <span class="hljs-keyword">new</span> DeadLockDemo(<span class="hljs-keyword">true</span>); A.setName(<span class="hljs-string">&quot;A 线程&quot;</span>);<br>    DeadLockDemo B = <span class="hljs-keyword">new</span> DeadLockDemo(<span class="hljs-keyword">false</span>); B.setName(<span class="hljs-string">&quot;B 线程&quot;</span>);<br>    A.start();<br>    B.start();<br>  &#125; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> Object o1 = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 保证多线程，共享一个对象,这里使用 static </span><br>  <span class="hljs-keyword">static</span> Object o2 = <span class="hljs-keyword">new</span> Object();<br>  <span class="hljs-keyword">boolean</span> flag;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLockDemo</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>&#123; <span class="hljs-comment">// 构造器 </span><br>    <span class="hljs-keyword">this</span>.flag = flag;<br>&#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 下面业务逻辑的分析</span><br>    <br>    <span class="hljs-comment">// 如果 flag 为 T, 线程 A 就会先持有 o1 对象锁, 然后尝试去获取 o2 对象锁 </span><br>    <span class="hljs-comment">// 如果线程 A 得不到 o2 对象锁，就会 Blocked</span><br>    <br>    <span class="hljs-comment">// 如果 flag 为 F, 线程 B 就会先持有 o2 对象锁, 然后尝试去获取 o1 对象锁 </span><br>    <span class="hljs-comment">// 如果线程 B 得不到 o1 对象锁，就会 Blocked</span><br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      <span class="hljs-keyword">synchronized</span> (o1) &#123;<span class="hljs-comment">//对象互斥锁, 下面就是同步代</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 1&quot;</span>); <br>        <span class="hljs-keyword">synchronized</span> (o2) &#123;<br>          <span class="hljs-comment">// 这里获得 li 对象的监视权</span><br>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 2&quot;</span>); &#125;<br>      &#125; <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">synchronized</span> (o2) &#123; <br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 3&quot;</span>); <br>        <span class="hljs-keyword">synchronized</span> (o1) &#123; <span class="hljs-comment">// 这里获得 li 对象的监视权</span><br>          System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 进入 4&quot;</span>); <br>        &#125;<br>      &#125; <br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><blockquote><p>释放锁的操作</p><p>当前线程的同步方法、同步代码块执行结束；</p><p>当前线程在同步方法、同步代码块中遇到 break、return；</p><p>当前线程在同步方法、同步代码块中出现了未处理的 Error 或者 Exception；</p><p>当前线程在同步方法、同步代码块中执行了 <code>wait()</code> 方法，使得线程暂停，并释放锁。</p><p>不会释放锁的操作</p><p>线程的同步方法、同步代码块执行 <code>Thread.sleep()</code>、<code>Thread.yield()</code>；</p><p>线程执行同步代码块，其他线程调用该线程的 <code>suspend()</code> 方法将该线程挂起。</p></blockquote><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。 </p><blockquote><ol><li><p>竞争资源 例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。 </p><p>系统中的资源可以分为两类：</p><ul><li>可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源； </li><li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。 </li></ul></li><li><p>进程推进顺序不当 </p><p>例如：进程 A 和 进程 B 互相等待对方的数据。</p></li></ol></blockquote><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><blockquote><ol><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用；</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放；</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ol></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1zB4y1A7rb?p=17">韩顺平-Java线程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatisPlus</title>
    <link href="/2021/08/25/mybatis-plus/"/>
    <url>/2021/08/25/mybatis-plus/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><p><em><strong>MyBatis-Plus</strong></em> 是一个 <em><strong>MyBatis</strong></em> 的增强工具，在 <em><strong>MyBatis</strong></em> 的基础上只做增强不做改变，为简化开发、提高 效率而生。</p><p><em><strong>官网：<a href="https://mp.baomidou.com/%E3%80%82">https://mp.baomidou.com/。</a></strong></em></p><p><strong>特性</strong></p><blockquote><p><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑；</p><p><strong>损耗小</strong>：启动即会自动注入基本 <em><strong>CURD</strong></em>，性能基本无损耗，直接面向对象操作；</p><p><strong>强大的 <em>CRUD</em> 操作</strong>：内置通用 <em><strong>Mapper</strong></em>、通用 <em><strong>Service</strong></em>，仅仅通过少量配置即可实现单表大部分 CRUD 操作， 更有强大的条件构造器，满足各类使用需求；</p><p><strong>支持 <em>Lambda</em> 形式调用</strong>：通过 <em><strong>Lambda</strong></em> 表达式，方便的编写各类查询条件，无需再担心字段写错；</p><p><strong>支持多种数据库</strong>：支持 <em><strong>MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer</strong></em> 等多种数据库；</p><p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - <em><strong>Sequence</strong></em>），可自由配置，完美解决主键问题；</p><p><strong>支持 <em>XML</em> 热加载</strong>：<em><strong>Mapper</strong></em> 对应的 <em><strong>XML</strong></em> 支持热加载，对于简单的 <em><strong>CRUD</strong></em> 操作，甚至可以无 <em><strong>XML</strong></em> 启动；</p><p><strong>支持 <em>ActiveRecord</em> 模式</strong>：支持 <em><strong>ActiveRecord</strong></em> 形式调用，实体类只需继承 <em><strong>Model</strong></em> 类即可进行强大的 <em><strong>CRUD</strong></em> 操作；</p><p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ <em><strong>Write once，use anywhere</strong></em> ）；</p><p><strong>支持关键词自动转义</strong>：支持数据库关键词（***order、key……***）自动转义，还可自定义关键词；</p><p><strong>内置代码生成器</strong>：采用代码或者 <em><strong>Maven</strong></em> 插件可快速生成 <em><strong>Mapper 、 Model 、 Service 、 Controller</strong></em> 层代码， 支持模板引擎，更有超多自定义配置等您来使用；</p><p><strong>内置分页插件</strong>：基于 <em><strong>MyBatis</strong></em> 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 <em><strong>List</strong></em> 查询；</p><p><strong>内置性能分析插件</strong>：可输出 <em><strong>Sql</strong></em> 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询；</p><p><strong>内置全局拦截插件</strong>：提供全表 <em><strong>delete 、 update</strong></em> 操作智能分析阻断，也可自定义拦截规则，预防误操作；</p><p><strong>内置 <em>Sql</em> 注入剥离器</strong>：支持 <em><strong>Sql</strong></em> 注入剥离，有效预防 <em><strong>Sql</strong></em> 注入攻击。</p></blockquote><p><strong>架构</strong></p><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-10-20%2016.38.01-20211031161503605.png"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>开发环境</li></ol><p>（ <em><strong>SpingBoot + mybatisplus</strong></em> ）</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-20 13.29.28.png" alt="" style="zoom:50%;" /><p>依赖引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1.tmp<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><em><strong>application.yml</strong></em> 配置数据库源</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>  <span class="hljs-comment"># 日志打印sql语句</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>创建 <em><strong>mapper</strong></em> 接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        userMapper.selectList(<span class="hljs-keyword">null</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h2><blockquote><p>映射数据库的表名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h2><blockquote><p>设置主键映射。</p><ul><li><p><em><strong>value</strong></em> 映射主键字段名</p></li><li><p><em><strong>type</strong></em> 设置主键类型，即主键的生成策略</p><p><em><strong>IdType</strong></em></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-20 14.30.14.png" alt="" style="zoom:50%;" /><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">IdType.<br><span class="hljs-attribute">AUTO</span>(<span class="hljs-number">0</span>)：数据库自增，开发者无需给主键赋值<br><span class="hljs-attribute">NONE</span>(<span class="hljs-number">1</span>)：MP设置主键，雪花算法<br><span class="hljs-selector-tag">INPUT</span>(<span class="hljs-number">2</span>)：需要开发者手动赋值，即传入主键的值<br>ASSIGN_ID(<span class="hljs-number">3</span>)：MP分配ID（Long、Integer、String），雪花算法<br>ASSIGN_UUID(<span class="hljs-number">4</span>),MP分配UUID（String）,主键必须是String，自动生成UUID进行赋值<br></code></pre></td></tr></table></figure></li></ul></blockquote><h2 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h2><blockquote><p>映射非主键字段。</p><ul><li><p><em><strong>value</strong></em> 映射字段名</p></li><li><p><em><strong>exist</strong></em> 表示是否为数据库字段 </p><p>如果实体类中的成员变量在数据库中没有对应的字段，则可以使用 <em><strong>@TableField(exist=false)</strong></em></p></li><li><p><em><strong>select</strong></em> 表示是否查询该字段</p></li><li><p><em><strong>fill</strong></em> 表示是否自动填充</p><p>将对象存入数据库的时候，由 <em><strong>MP</strong></em> 自动给某些字段赋值</p><ol><li><p>数据库表中添加 <em><strong>create_time、update_time</strong></em></p></li><li><p>实体类添加 <em><strong>create_time、update_time</strong></em></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-meta">@TableField(value = &quot;name&quot;,select = false)</span> <span class="hljs-comment">// 不查询该字段</span><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField(exist = false)</span> <span class="hljs-comment">// 该字段在数据库中不存在</span><br>    <span class="hljs-keyword">private</span> String gender;<br><br>  <span class="hljs-comment">// create_time</span><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br>  <span class="hljs-comment">// update_time</span><br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>创建自动填充处理器</li></ol><p><em><strong>MetaObjectHandler</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// com.tsuirka.handler.MyMetaObjectHandler</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<br>  <span class="hljs-comment">// 插入字段时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;createTime&quot;</span>, <span class="hljs-keyword">new</span> Date(), metaObject);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, <span class="hljs-keyword">new</span> Date(), metaObject);<br>    &#125; <br><br>  <span class="hljs-comment">// 修改字段时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, <span class="hljs-keyword">new</span> Date(), metaObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Version"><a href="#Version" class="headerlink" title="@Version"></a>@Version</h2><blockquote><p>标记乐观锁，通过 <em><strong>version</strong></em> 字段来保证数据的安全性，当修改数据的时候，会以 <em><strong>version</strong></em> 作为条件，当条件成立的时候才会修改成功。</p><ol><li>数据库表添加 <em><strong>version</strong></em> 字段，默认值为 1</li><li>实体类添加 <em><strong>version</strong></em> 成员变量，并且添加注解 <em><strong>@Version</strong></em> </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-meta">@TableField(value = &quot;name&quot;,select = false)</span><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br>    <span class="hljs-meta">@Version</span> <span class="hljs-comment">// 乐观锁</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>注册配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// com.tsuiraku.config.MyBatisPlusConfig</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisPlusConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="EnumValue"><a href="#EnumValue" class="headerlink" title="@EnumValue"></a>@EnumValue</h2><blockquote><p>通用枚举类注解，将数据库字段映射成实体类的枚举类型成员变量。</p><ol><li>注解方式实现枚举</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// com.tsuiraku.mybatisplus.enums</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">StatusEnum</span> </span>&#123;<br>    WORK(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;上班&quot;</span>),<br>    REST(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;休息&quot;</span>);<br><br>    StatusEnum(Integer code, String msg) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-meta">@EnumValue</span><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String msg;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-meta">@TableField(value = &quot;name&quot;,select = false)</span><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br>    <span class="hljs-meta">@Version</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>  <span class="hljs-comment">// 枚举类型</span><br>    <span class="hljs-keyword">private</span> StatusEnum status;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># application.yml</span><br><span class="hljs-attr">mybatis-plus:</span><br><span class="hljs-attr">type-enums-package:</span> <br>  <span class="hljs-string">com.tsuiraku.mybatisplus.enums</span><br></code></pre></td></tr></table></figure><ol start="2"><li>接口方式实现枚举</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AgeEnum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IEnum</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    ONE(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;一岁&quot;</span>),<br>    TWO(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;两岁&quot;</span>),<br>    THREE(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;三岁&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String msg;<br><br>    AgeEnum(Integer code, String msg) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.code;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a>@TableLogic</h2><blockquote><p>映射逻辑删除。</p><ol><li>数据表添加 <em><strong>deleted</strong></em> 字段</li><li>实体类添加注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-meta">@TableField(value = &quot;name&quot;,select = false)</span><br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> AgeEnum age;<br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br>    <span class="hljs-meta">@Version</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>    <span class="hljs-meta">@TableField(value = &quot;status&quot;)</span><br>    <span class="hljs-keyword">private</span> StatusEnum statusEnum;<br><br>  <span class="hljs-comment">// 逻辑删除</span><br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> Integer deleted;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><em><strong>application.yml</strong></em> 配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br><span class="hljs-attr">global-config:</span><br>  <span class="hljs-attr">db-config:</span><br>    <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h1><p>通过继承 <em><strong>BaseMapper</strong></em> 就可以获取到各种各样的单表操作。<em><strong>（ <u>Mapper CRUD 接口</u> ）</strong></em></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-20 14.19.47.png" style="zoom:50%;" /><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><blockquote><p>插入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入一条记录</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(T entity)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">entity</td><td align="center">实体对象</td></tr></tbody></table><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><blockquote><p>删除。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 entity 条件，删除记录</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span></span>;<br><span class="hljs-comment">// 删除（根据ID 批量删除）</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteBatchIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;<br><span class="hljs-comment">// 根据 ID 删除</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Serializable id)</span></span>;<br><span class="hljs-comment">// 根据 columnMap 条件，删除记录</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Wrapper&lt;T&gt;</td><td align="center">wrapper</td><td align="center">实体对象封装操作类（可以为 null）</td></tr><tr><td align="center">Collection&lt;? extends Serializable&gt;</td><td align="center">idList</td><td align="center">主键ID列表(不能为 null 以及 empty)</td></tr><tr><td align="center">Serializable</td><td align="center">id</td><td align="center">主键ID</td></tr><tr><td align="center">Map&lt;String, Object&gt;</td><td align="center">columnMap</td><td align="center">表字段 map 对象</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><blockquote><p>更新。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 whereWrapper 条件，更新记录</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.ENTITY)</span> T updateEntity, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span></span>;<br><span class="hljs-comment">// 根据 ID 修改</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateById</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.ENTITY)</span> T entity)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">entity</td><td align="center">实体对象 (set 条件值,可为 null)</td></tr><tr><td align="center">Wrapper&lt;T&gt;</td><td align="center">updateWrapper</td><td align="center">实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td></tr></tbody></table><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><blockquote><p>查询。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 ID 查询</span><br><span class="hljs-function">T <span class="hljs-title">selectById</span><span class="hljs-params">(Serializable id)</span></span>;<br><span class="hljs-comment">// 根据 entity 条件，查询一条记录</span><br><span class="hljs-function">T <span class="hljs-title">selectOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br><br><span class="hljs-comment">// 查询（根据ID 批量查询）</span><br><span class="hljs-function">List&lt;T&gt; <span class="hljs-title">selectBatchIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;<br><span class="hljs-comment">// 根据 entity 条件，查询全部记录</span><br><span class="hljs-function">List&lt;T&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br><span class="hljs-comment">// 查询（根据 columnMap 条件）</span><br><span class="hljs-function">List&lt;T&gt; <span class="hljs-title">selectByMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span></span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录</span><br>List&lt;Map&lt;String, Object&gt;&gt; selectMaps(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper);<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span><br><span class="hljs-function">List&lt;Object&gt; <span class="hljs-title">selectObjs</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br><br><span class="hljs-comment">// 根据 entity 条件，查询全部记录（并翻页）</span><br><span class="hljs-function">IPage&lt;T&gt; <span class="hljs-title">selectPage</span><span class="hljs-params">(IPage&lt;T&gt; page, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br><span class="hljs-comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span><br>IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper);<br><span class="hljs-comment">// 根据 Wrapper 条件，查询总记录数</span><br><span class="hljs-function">Integer <span class="hljs-title">selectCount</span><span class="hljs-params">(<span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br></code></pre></td></tr></table></figure><p> <strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Serializable</td><td align="center">id</td><td align="center">主键ID</td></tr><tr><td align="center">Wrapper&lt;T&gt;</td><td align="center">queryWrapper</td><td align="center">实体对象封装操作类（可以为 null）</td></tr><tr><td align="center">Collection&lt;? extends Serializable&gt;</td><td align="center">idList</td><td align="center">主键ID列表(不能为 null 以及 empty)</td></tr><tr><td align="center">Map&lt;String, Object&gt;</td><td align="center">columnMap</td><td align="center">表字段 map 对象</td></tr><tr><td align="center">IPage&lt;T&gt;</td><td align="center">page</td><td align="center">分页查询条件（可以为 RowBounds.DEFAULT）</td></tr></tbody></table><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ol><li>注册配置类拦截器 <em><strong>PaginationInterceptor</strong></em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// com.tsuiraku.config.MyBatisPlusConfig</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisPlusConfig</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* Page&lt;&gt;(param1, parma2)</span><br><span class="hljs-comment">* 参数1：页数</span><br><span class="hljs-comment">* 参数2：每页记录数</span><br><span class="hljs-comment">*/</span><br>Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Page&lt;User&gt; res = mapper.selectPage(page, <span class="hljs-keyword">null</span>);<br>res.getSize();<span class="hljs-comment">// 每页记录数</span><br>res.getTotal();<span class="hljs-comment">// 总记录数</span><br>res.getRecords(); <span class="hljs-comment">// 结果</span><br><br>Page&lt;Map&lt;String, Object&gt;&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Page&lt;User&gt; res = mapper.selectMapsPage(page, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><h2 id="自定义SQL（多表关联查询）"><a href="#自定义SQL（多表关联查询）" class="headerlink" title="自定义SQL（多表关联查询）"></a>自定义SQL（多表关联查询）</h2><p><em><strong>User</strong></em></p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>tsuiraku</td><td>21</td></tr><tr><td>2</td><td>nanase</td><td>26</td></tr></tbody></table><p><em><strong>Grade</strong></em></p><table><thead><tr><th>id</th><th>u_id</th><th>score</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>100</td></tr><tr><td>20</td><td>2</td><td>99</td></tr></tbody></table><p><em><strong>Vo</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vo</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String score;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>Mapper</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span><span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@Select(&quot;select u.name,g.score from user u,grade g where u.id = g.u_id and u.id = 1&quot;)</span><br>  <span class="hljs-function">List&lt;Vo&gt; <span class="hljs-title">listVo</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h1><blockquote><p><em><strong>AutoGenerator</strong></em> 是 <em><strong>MyBatis-Plus</strong></em> 的代码生成器，通过 <em><strong>AutoGenerator</strong></em> 可以快速生成 <em><strong>Entity、Mapper、Mapper、XML、Service、Controller</strong></em> 等各个模块的代码，极大的提升了开发效率。</p></blockquote><ol><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1.tmp<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>代码生成器模版解析（历史版本）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建generator对象</span><br>    AutoGenerator autoGenerator = <span class="hljs-keyword">new</span> AutoGenerator();<br>    <span class="hljs-comment">// 设置数据源</span><br>    DataSourceConfig dataSourceConfig = <span class="hljs-keyword">new</span> DataSourceConfig();<br>    dataSourceConfig.setDbType(DbType.MYSQL);<br>    dataSourceConfig.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/database&quot;</span>);<br>    dataSourceConfig.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>    dataSourceConfig.setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>    dataSourceConfig.setDriverName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>    autoGenerator.setDataSource(dataSourceConfig);<br>    <span class="hljs-comment">// 设置全局配置</span><br>    GlobalConfig globalConfig = <span class="hljs-keyword">new</span> GlobalConfig();<br>    globalConfig.setOutputDir(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;/src/main/java&quot;</span>); <span class="hljs-comment">// 输出路径</span><br>    globalConfig.setOpen(<span class="hljs-keyword">false</span>); <span class="hljs-comment">// 创建完毕后是否自动打开</span><br>    globalConfig.setAuthor(<span class="hljs-string">&quot;tsuiraku&quot;</span>); <span class="hljs-comment">// 作者</span><br>    globalConfig.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>) <span class="hljs-comment">// 生成Service而不是iService</span><br>    autoGenerator.setGlobalConfig(globalConfig);<br>    <span class="hljs-comment">// 设置包信息</span><br>    PackageConfig packageConfig = <span class="hljs-keyword">new</span> PackageConfig();<br>    packageConfig.setParent(<span class="hljs-string">&quot;com.tsuiraku&quot;</span>); <span class="hljs-comment">// 父包</span><br>    packageConfig.setModuleName(<span class="hljs-string">&quot;generator&quot;</span>); <span class="hljs-comment">// 设置生成包的名字</span><br>    packageConfig.setController(<span class="hljs-string">&quot;controller&quot;</span>);<br>    packageConfig.setService(<span class="hljs-string">&quot;service&quot;</span>); <br>    packageConfig.setServiceImpl(<span class="hljs-string">&quot;service.impl&quot;</span>);<br>    packageConfig.setMapper(<span class="hljs-string">&quot;mapper&quot;</span>);<br>    packageConfig.setEntity(<span class="hljs-string">&quot;entity&quot;</span>);<br>    autoGenerator.setPackageInfo(packageConfig);<br>    <span class="hljs-comment">// 设置配置策略</span><br>    StrategyConfig strategyConfig = <span class="hljs-keyword">new</span> StrategyConfig();<br>    strategyConfig.setEntityLombokModel(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// lombok</span><br>    strategyConfig.setNaming(NamingStrategy.underline_to_camel); <span class="hljs-comment">// 驼峰命名</span><br>    strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel); <span class="hljs-comment">// 驼峰命名</span><br>    autoGenerator.setStrategy(strategyConfig);<br>    autoGenerator.execute();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1yA411t782?p=1">Java-楠哥</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>数据库</category>
      
      <category>ORM层框架</category>
      
      <category>MybatisPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatisplus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/08/19/redis/"/>
    <url>/2021/08/19/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><em><strong>Redis</strong></em> 是典型的 <em><strong>NoSQL</strong></em> 数据库。</p><p><em><strong>redis官网</strong></em>：<a href="https://redis.io/download">https://redis.io/download</a> </p><blockquote><p><em><strong>Redis</strong></em> 是一个开源的 <em><strong>key-value</strong></em> 存储系统。</p><p>和 <em><strong>Memcached</strong></em> 类似，它支持存储的 <em><strong>value</strong></em> 类型相对更多，包括 <em><strong>string、list、set、zset、sorted set、hash</strong></em>。</p><p>这些数据类型都支持 <em><strong>push/pop、add/remove</strong></em> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><p>在此基础上，<em><strong>Redis</strong></em> 支持各种不同方式的排序。</p><p>与 <em><strong>memcached</strong></em>一样，为了保证效率，数据都是缓存在内存中。</p><p>区别的是 <em><strong>Redis</strong></em> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p><p>并且在此基础上实现了<em><strong>master-slave</strong></em> （主从）同步。</p><p>单线程 + <em><strong>IO</strong></em> 多路复用。</p></blockquote><h1 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h1><blockquote><p>安装 <em><strong>C</strong></em> 语言的编译环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs base">yum install centos-release-scl scl-utils-build<br>yum install -y devtoolset-8-toolchain<br>scl enable devtoolset-8 bash<br></code></pre></td></tr></table></figure><p>通过 <em><strong>wget</strong></em> 下载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>download.redis.io<span class="hljs-regexp">/releases/</span>redis-<span class="hljs-number">6.2</span>.<span class="hljs-number">6</span>.tar.gz<br><br><span class="hljs-regexp">//</span> 下载路径：/opt<br></code></pre></td></tr></table></figure><p>解压至当前目录</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf redis-<span class="hljs-number">6</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.tar.gz <br></code></pre></td></tr></table></figure><p>解压完成后进入目录</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> redis-<span class="hljs-number">6</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>在当前目录下执行 <em><strong>make</strong></em></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> &amp;&amp; <span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure><p>默认安装在 <code>/usr/local/bin</code></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-21 22.16.18.png" style="zoom:50%;" /><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-<span class="hljs-keyword">check</span>-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-<span class="hljs-keyword">check</span>-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-<span class="hljs-keyword">server</span>：Redis服务器启动命令<br>redis-cli：客户端，操作入口<br></code></pre></td></tr></table></figure><p>前台启动：***/usr/local/bin*** 目录下启动 <em><strong>redis</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server(前台启动)<br></code></pre></td></tr></table></figure><p>后台启动：</p><ul><li><p>安装 <em><strong>redis</strong></em> 的目录 <em><strong>/opt/redis-6.2.6</strong></em> 中将 <em><strong>redis.conf</strong></em> 复制到任意一个文件夹下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp redis.conf <span class="hljs-regexp">/etc/</span>redis.conf<br><span class="hljs-regexp">//</span> 将redis.conf复制到<span class="hljs-regexp">/etc/</span>下<br></code></pre></td></tr></table></figure></li><li><p>修改 <em><strong>/etc/redis.conf</strong></em> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim redis.conf<span class="hljs-comment"># daemonize no 修改为 daemonize yes</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-21 22.55.41.png" style="zoom:50%;" /></li><li><p><em><strong>/usr/local/bin</strong></em> 目录下启动 <em><strong>redis</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server /etc/redis.conf<br></code></pre></td></tr></table></figure></li></ul><p>关闭 <em><strong>redis</strong></em></p><ul><li><em><strong>kill</strong></em> 进程</li><li>命令 <em><strong>shutdown</strong></em></li></ul></blockquote><p><u><strong>默认端口号：6379</strong></u></p><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><ul><li><p>解决 <em><strong>CPU</strong></em> 及内存压力</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211021213413082.png" style="zoom:50%;" /></li><li><p>解决 <em><strong>IO</strong></em> 压力</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211021213423883.png" style="zoom:50%;" /></li></ul><p><em><strong>NoSQL（ NoSQL = Not Only SQL ）</strong></em>，意即不仅仅是 <em><strong>SQL</strong></em>，泛指非关系型的数据库。 </p><p><em><strong>NoSQL</strong></em> 不依赖业务逻辑方式存储，而以简单的 <em><strong>key-value</strong></em> 模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循 <em><strong>SQL</strong></em> 标准。</li><li>不支持 <em><strong>ACID</strong></em>。</li><li>远超于 <em><strong>SQL</strong></em> 的性能。</li></ul><p><strong>适用于的场景</strong></p><ul><li>对数据高并发的读写；</li><li>海量数据的读写；</li><li>对数据高可扩展性的。</li></ul><p><strong>不适用的场景</strong></p><ul><li>需要事务支持；</li><li>基于 <em><strong>sql</strong></em> 的结构化查询存储，处理复杂的关系，需要即席查询。</li></ul><p>常见的 <em><strong>NoSQL</strong></em> 数据库</p><ul><li>Redis</li><li>MongoDB</li></ul><p>大数据时代常用的数据库类型</p><ul><li><p>行式数据库</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211021215032857.png" style="zoom:50%;" /></li><li><p>列式数据库</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211021215041246.png" style="zoom:50%;" /></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><em><strong>redis.conf</strong></em></p><h2 id="Units"><a href="#Units" class="headerlink" title="Units"></a><em><strong>Units</strong></em></h2><blockquote><p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <em><strong>bytes</strong></em>，不支持 <em><strong>bit</strong></em>。</p><p>大小写不敏感。</p></blockquote><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.30.10.png" style="zoom:50%;" /><h2 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a><em><strong>INCLUDES</strong></em></h2><blockquote><p>包含，多实例的情况可以把公用的配置文件提取出来。</p></blockquote><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.32.49.png" style="zoom:50%;" /><h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a><em><strong>NETWORK</strong></em></h2><blockquote><p>网络相关配置。</p><p><em><strong>bind</strong></em></p><p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p><p>不写的情况下，无限制接受任何 <em><strong>ip</strong></em> 地址的访问。</p><p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，*<u>所以需要将其注释掉</u>*。</p><p>如果开启了<em><strong>protected-mode</strong></em>，那么在没有设定 <em><strong>bind ip</strong></em> 且没有设密码的情况下，<em><strong>Redis</strong></em> 只允许接受本机的响应。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.36.24.png" style="zoom:50%;" /><p><em><strong>protected-mode</strong></em></p><p>将本机访问保护模式设置 <em><strong>no</strong></em>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.38.19.png" style="zoom:50%;" /><p><em><strong>port</strong></em></p><p>端口号，默认 <em><strong>6379</strong></em>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.39.11.png" alt="截屏2021-10-22 13.39.11" style="zoom:50%;" /><p><em><strong>tcp-backlog</strong></em></p><p>设置 <em><strong>tcp</strong></em> 的 <em><strong>backlog</strong></em>，<em><strong>backlog</strong></em> 其实是一个连接队列，<em><strong>backlog</strong></em> 队列总和 $=$ 未完成三次握手队列 $+$ 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高 <em><strong>backlog</strong></em> 值来避免慢客户端连接问题。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.46.22.png" style="zoom:50%;" /><p><em><strong>timeout</strong></em></p><p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.47.26.png" style="zoom:50%;" /><p><em><strong>tcp-keepalive</strong></em></p><p>对访问客户端的一种心跳检测，每个 <em><strong>n</strong></em> 秒检测一次。</p><p>单位为秒，如果设置为 0，则不会进行 <em><strong>Keepalive</strong></em> 检测，建议设置成 60。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.48.06.png" style="zoom:50%;" /></blockquote><h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a><em><strong>GENERAL</strong></em></h2><blockquote><p>通用。</p><p><em><strong>daemonize</strong></em></p><p>是否为后台进程，设置为 <em><strong>yes</strong></em>。</p><p>守护进程，后台启动。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.50.16.png" alt="" style="zoom:50%;" /><p><em><strong>pidfile</strong></em></p><p>存放 <em><strong>pid</strong></em> 文件的位置，每个实例会产生一个不同的 <em><strong>pid</strong></em> 文件。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.51.10.png" alt="" style="zoom:50%;" /><p><em><strong>loglevel</strong></em></p><p>指定日志记录级别，<em><strong>Redis</strong></em> 总共支持四个级别：<em><strong>debug、verbose、notice、warning</strong></em>，默认为 <em><strong>notice</strong></em>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.52.01.png" style="zoom:50%;" /><p><em><strong>logfile</strong></em></p><p>日志文件名称。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.52.28.png" alt="" style="zoom:50%;" /><p><em><strong>database</strong></em></p><p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <em><strong>id</strong></em>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 13.53.17.png" alt="" style="zoom:50%;" /></blockquote><h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a><em><strong>SECURITY</strong></em></h2><blockquote><p>安全。</p><p>访问密码的查看、设置和取消。</p><p>在命令中设置密码，只是临时的。重启 <em><strong>redis</strong></em> 服务器，密码就还原了。</p><p>永久设置，需要在配置文件中进行设置。</p></blockquote><h2 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a><em><strong>LIMITS</strong></em></h2><blockquote><p>限制。</p><p><em><strong>maxclients</strong></em></p><p>设置 <em><strong>redis</strong></em> 同时可以与多少个客户端进行连接。</p><p>默认情况下为 <em><strong>10000</strong></em> 个客户端。</p><p>如果达到了此限制，<em><strong>redis</strong></em> 则会拒绝新的连接请求，并且向这些连接请求方发出 <em><strong>max number of clients reached</strong></em> 以作回应。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 14.05.40.png" style="zoom:50%;" /><p><em><strong>maxmemory</strong></em></p><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p><p>设置 <em><strong>redis</strong></em> 可以使用的内存量。一旦到达内存使用上限，<em><strong>redis</strong></em> 将会试图移除内部数据，移除规则可以通过 <em><strong>maxmemory-policy</strong></em> 来指定。</p><p>如果 <em><strong>redis</strong></em> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <em><strong>redis</strong></em> 则会针对那些需要申请内存的指令返回错误信息，比如 <em><strong>SET、LPUSH</strong></em> 等。</p><p>但是对于无内存申请的指令，仍然会正常响应，比如 <em><strong>GET</strong></em> 等。如果你的 <em><strong>redis</strong></em> 是主 <em><strong>redis</strong></em>（ 说明你的 <em><strong>redis</strong></em> 有从 <em><strong>redis</strong></em> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 14.05.58.png" style="zoom:50%;" /><p><em><strong>maxmemory-policy</strong></em></p><p><em><strong>volatile-lru</strong></em>：使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>，只对设置了过期时间的键（最近最少使用）。</p><p><em><strong>allkeys-lru</strong></em>：在所有集合 <em><strong>key</strong></em> 中，使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>。</p><p><em><strong>volatile-random</strong></em>：在过期集合中移除随机的 <em><strong>key</strong></em>，只对设置了过期时间的键。</p><p><em><strong>allkeys-random</strong></em>：在所有集合 <em><strong>key</strong></em> 中，移除随机的 <em><strong>key</strong></em>。</p><p><em><strong>volatile-ttl</strong></em>：移除那些 <em><strong>TTL</strong></em> 值最小的 <em><strong>key</strong></em>，即那些最近要过期的 <em><strong>key</strong></em>。</p><p><em><strong>noeviction</strong></em>：不进行移除。针对写操作，只是返回错误信息。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 14.08.09.png" style="zoom:50%;" /><p><em><strong>maxmemory-samples</strong></em></p><p>设置样本数量，<em><strong>LRU</strong></em> 算法和最小 <em><strong>TTL</strong></em> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<em><strong>redis</strong></em> 默认会检查这么多个 <em><strong>key</strong></em> 并选择其中 <em><strong>LRU</strong></em> 的那个。</p><p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 14.09.11.png" style="zoom:50%;" /></blockquote><h1 id="常用五大基本数据类型"><a href="#常用五大基本数据类型" class="headerlink" title="常用五大基本数据类型"></a>常用五大基本数据类型</h1><h2 id="key操作"><a href="#key操作" class="headerlink" title="key操作"></a>key操作</h2><blockquote><p><code>keys *</code>：查看当前库所有 <em><strong>key</strong></em>  </p><p><code>exists key</code>：判断某个 <em><strong>key</strong></em> 是否存在</p><p><code>type key</code>：查看你的 <em><strong>key</strong></em> 是什么类型</p><p><code>del key</code> ：删除指定的 <em><strong>key</strong></em> 数据</p><p><code>unlink key</code>：根据 <em><strong>value</strong></em> 选择非阻塞删除，仅将 <em><strong>keys</strong></em> 从 <em><strong>keyspace</strong></em> 元数据中删除，真正的删除会在后续异步操作</p><p><code>expire key 10</code> ：为给定的 <em><strong>key</strong></em> 设置过期时间</p><p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p><p><code>select</code>：命令切换数据库</p><p><code>dbsize</code>：查看当前数据库的 <em><strong>key</strong></em> 的数量</p><p><code>flushdb</code>：清空当前库</p><p><code>flushall</code>：通杀全部库</p></blockquote><h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><p><em><strong>String</strong></em> 类型是二进制安全的。意味着 <em><strong>Redis</strong></em> 的 <em><strong>string</strong></em> 可以包含任何数据。比如 <em><strong>jpg</strong></em> 图片或者序列化的对象。</p><p><em><strong>String</strong></em> 类型是 <em><strong>Redis</strong></em> 最基本的数据类型，一个 <em><strong>Redis</strong></em> 中字符串 <em><strong>value</strong></em> 最多可以是 512M。</p><blockquote><p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p><p><code>get &lt;key&gt;</code>：查询对应键值</p><p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <em><strong>&lt;value&gt;</strong></em> 追加到原值的末尾</p><p><code>strlen &lt;key&gt;</code>：获得值的长度</p><p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <em><strong>key</strong></em> 不存在时，设置 <em><strong>key</strong></em> 的值</p><p><code>incr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（**<u>具有原子性</u>**）</p><p><code>decr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p><p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增减。自定义步长</p><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <em><strong>key-value</strong></em> 对 </p><p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <em><strong>value</strong></em> </p><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;... </code>：同时设置一个或多个 <em><strong>key-value</strong></em> 对，当且仅当所有给定 <em><strong>key</strong></em> 都不存在    </p><p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p><p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <em><strong>&lt;value&gt;</strong></em> 覆写 <em><strong>&lt;key&gt;</strong></em> 所储存的字符串值</p><p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p><p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p></blockquote><p><strong>原子性</strong></p><p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <em><strong>context switch</strong></em> （切换到另一个线程）。</p><ul><li><p>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p></li><li><p>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p></li></ul><p><em><strong>Redis</strong></em> 单命令的原子性主要得益于 <em><strong>Redis</strong></em> 的单线程。</p><p><strong>数据结构</strong></p><p>内部结构实现上类似于 <em><strong>Java</strong></em> 的 <em><strong>ArrayList</strong></em>，采用预分配冗余空间的方式来减少内存的频繁分配.</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211022000751746.png" style="zoom:50%;" /><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><p><em><strong>Redis</strong></em> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211022121129201.png" style="zoom:50%;" /><blockquote><p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边/右边插入一个或多个值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lpush</span> k<span class="hljs-number">1</span> v<span class="hljs-number">1</span> v<span class="hljs-number">2</span> v<span class="hljs-number">3</span>lrange k<span class="hljs-number">1</span> <span class="hljs-number">0</span> -<span class="hljs-number">1</span>输出：v<span class="hljs-number">3</span> v<span class="hljs-number">2</span> v<span class="hljs-number">1</span>rpush k<span class="hljs-number">1</span> v<span class="hljs-number">1</span> v<span class="hljs-number">2</span> v<span class="hljs-number">3</span>rrange k<span class="hljs-number">1</span> <span class="hljs-number">0</span> -<span class="hljs-number">1</span>输出：v<span class="hljs-number">1</span> v<span class="hljs-number">2</span> v<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><code>lpop/rpop &lt;key&gt;</code>：从左边/右边吐出一个值。值在键在，值光键亡。</p><p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <em><strong>&lt;key1&gt;</strong></em> 列表右边吐出一个值，插到 <em><strong>&lt;key2&gt;</strong></em> 列表左边。</p><p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>lrange mylist 0 -1  0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p><p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p><p><code>llen &lt;key&gt;</code>：获得列表长度  </p><p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <em><strong>&lt;value&gt;</strong></em> 的前面/后面插入 <em><strong>&lt;newvalue&gt;</strong></em> 插入值</p><p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <em><strong>n</strong></em> 个 <em><strong>value</strong></em>（从左到右）</p><p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <em><strong>key</strong></em> 下标为 <em><strong>index</strong></em> 的值替换成 <em><strong>value</strong></em></p></blockquote><p><strong>数据结构</strong></p><p><em><strong>List</strong></em> 的数据结构为快速链表 <em><strong>quickList</strong></em>。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <em><strong>ziplist</strong></em>，也即是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成 <em><strong>quicklist</strong></em>。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <em><strong>int</strong></em> 类型的数据，结构上还需要两个额外的指针 <em><strong>prev</strong></em> 和 <em><strong>next</strong></em>。</p><p><em><strong>Redis</strong></em> 将链表和 <em><strong>ziplist</strong></em> 结合起来组成了 <em><strong>quicklist</strong></em>。也就是将多个 <em><strong>ziplist</strong></em> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20211022122514593.png" style="zoom:50%;" /><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p><em><strong>Set</strong></em> 对外提供的功能与 <em><strong>List</strong></em> 类似列表的功能，特殊之处在于 <em><strong>Set</strong></em> 是可以 <strong><u>自动排重</u></strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<em><strong>Set</strong></em> 是一个很好的选择，并且 <em><strong>Set</strong></em> 提供了判断某个成员是否在一个 <em><strong>Set</strong></em> 集合内的重要接口，这个也是 <em><strong>List</strong></em> 所不能提供的。</p><p><em><strong>Redis</strong></em> 的 <em><strong>Set</strong></em> 是 <em><strong>String</strong></em> 类型的无序集合。它底层其实是一个 <em><strong>value</strong></em> 为 <em><strong>null</strong></em> 的 <em><strong>hash</strong></em> 表，所以添加，删除，查找的复杂度都是 ***O(1)***。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是 ***O(1)***，数据增加，查找数据的时间不变。</p><blockquote><p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... </code>：将一个或多个 <em><strong>member</strong></em> 元素加入到集合 <em><strong>key</strong></em> 中，已经存在的 <em><strong>member</strong></em> 元素将被忽略</p><p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p><p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <em><strong>&lt;key&gt;</strong></em> 是否为含有该 <em><strong>&lt;value&gt;</strong></em> 值，有返回 1，没有返回 0</p><p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p><p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p><p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p><p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <em><strong>n</strong></em> 个值，不会从集合中删除 </p><p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p><p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p><p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p><p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<em><strong>key1</strong></em> 中的，不包含 <em><strong>key2</strong></em> 中的）</p></blockquote><p><strong>数据结构</strong></p><p><em><strong>Set</strong></em> 数据结构是字典，字典是用哈希表实现的。</p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p><em><strong>Redis hash</strong></em> 是一个键值对集合。</p><p><em><strong>Redis hash</strong></em> 是一个 <em><strong>String</strong></em> 类型的 <em><strong>field</strong></em> 和 <em><strong>value</strong></em> 的映射表，<em><strong>hash</strong></em> 特别适合用于存储对象。</p><blockquote><p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <em><strong>&lt;key&gt;</strong></em> 集合中的 <em><strong>&lt;field&gt;</strong></em> 键赋值 <em><strong>&lt;value&gt;</strong></em></p><p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <em><strong>&lt;key1&gt;</strong></em> 集合 <em><strong>&lt;field&gt;</strong></em> 取出 <em><strong>value</strong></em> </p><p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <em><strong>hash</strong></em> 的值</p><p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <em><strong>key</strong></em> 中，给定域 <em><strong>field</strong></em> 是否存在</p><p><code>hkeys &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>field</strong></em></p><p><code>hvals &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>value</strong></em></p><p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值加上增量 1  -1</p><p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值设置为 <em><strong>value</strong></em> ，当且仅当域 <em><strong>field</strong></em> 不存在</p></blockquote><p><strong>数据结构</strong></p><p><em><strong>Hash</strong></em> 类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）。</p><p>当 <em><strong>field-value</strong></em> 长度较短且个数较少时，使用 <em><strong>ziplist</strong></em>，否则使用 <em><strong>hashtable</strong></em>。</p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><p><em><strong>Redis</strong></em> 有序集合 <em><strong>zset</strong></em> 与普通集合 <em><strong>set</strong></em> 非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个评分（<em><strong>score</strong></em>）,这个评分（<em><strong>score</strong></em>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p><p>因为元素是有序的，所以可以很快的根据评分（<em><strong>score</strong></em>）或者次序（<em><strong>position</strong></em>）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p><blockquote><p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <em><strong>member</strong></em> 元素及其 <em><strong>score</strong></em> 值加入到有序集 <em><strong>key</strong></em> 当中</p><p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]  </code>：返回有序集 <em><strong>key</strong></em> 中，下标在 <em><strong>&lt;start&gt;&lt;stop&gt;</strong></em> 之间的元素</p><p>当带 <em><strong>WITHSCORES</strong></em>，可以让分数一起和值返回到结果集</p><p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <em><strong>key</strong></em> 中，所有 <em><strong>score</strong></em> 值介于 <em><strong>min</strong></em> 和 <em><strong>max</strong></em> 之间（包括等于 <em><strong>min</strong></em> 或 <em><strong>max</strong></em> ）的成员。有序集成员按 <em><strong>score</strong></em> 值递增（从小到大）次序排列。</p><p><code>zrevrangebyscore key max min [withscores] [limit offset count] </code>：同上，改为从大到小排列</p><p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <em><strong>score</strong></em> 加上增量</p><p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p><p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数 </p><p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p></blockquote><p><strong>数据结构</strong></p><p><em><strong>SortedSet（zset）</strong></em>是 <em><strong>Redis</strong></em> 提供的一个非常特别的数据结构，一方面它等价于 <em><strong>Java</strong></em> 的数据结构 ***Map&lt;String, Double&gt;***，可以给每一个元素 <em><strong>value</strong></em> 赋予一个权重 <em><strong>score</strong></em>，另一方面它又类似于 <em><strong>TreeSet</strong></em>，内部的元素会按照权重 <em><strong>score</strong></em> 进行排序，可以得到每个元素的名次，还可以通过 <em><strong>score</strong></em> 的范围来获取元素的列表。</p><p><em><strong>zset</strong></em> 底层使用了两个数据结构</p><ul><li><p><em><strong>hash</strong></em>，<em><strong>hash</strong></em> 的作用就是关联元素 <em><strong>value</strong></em> 和权重 <em><strong>score</strong></em>，保障元素 <em><strong>value</strong></em> 的唯一性，可以通过元素 <em><strong>value</strong></em> 找到相应的 <em><strong>score</strong></em> 值</p></li><li><p>跳跃表，跳跃表的目的在于给元素 <em><strong>value</strong></em> 排序，根据 <em><strong>score</strong></em> 的范围获取元素列表</p></li></ul><h1 id="Redis6新数据结构"><a href="#Redis6新数据结构" class="headerlink" title="Redis6新数据结构"></a>Redis6新数据结构</h1><p>$###################\space to \space do\space ###################$</p><h1 id="Redis的发布与订阅"><a href="#Redis的发布与订阅" class="headerlink" title="Redis的发布与订阅"></a>Redis的发布与订阅</h1><p><em><strong>Redis</strong></em> 发布订阅（ <em><strong>pub/sub</strong></em> ）是一种消息通信模式：发送者（ <em><strong>pub</strong></em> ）发送消息，订阅者（ <em><strong>sub</strong></em> ）接收消息。</p><p><em><strong>Redis</strong></em> 客户端可以订阅任意数量的频道。</p><ol><li>客户端可以订阅频道</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 14.18.02.png" alt="" style="zoom:50%;" /><ol start="2"><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-22 14.21.40.png" style="zoom:50%;" /><blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">subscribe </span>channel <span class="hljs-comment"># 订阅频道</span><br><br>publish channel hello <span class="hljs-comment"># 频道发送信息</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h1><p><em><strong>Redis</strong></em> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p><em><strong>Redis</strong></em> 事务的主要作用就是串联多个命令防止别的命令插队。</p><h2 id="Multi、Exec、Discard"><a href="#Multi、Exec、Discard" class="headerlink" title="Multi、Exec、Discard"></a><em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><img src="/Users/nanase/Library/Application Support/typora-user-images/截屏2021-10-27 18.12.45.png" style="zoom:50%;" /><blockquote><p><em><strong>Multi</strong></em></p><p><em><strong>Exec</strong></em></p><p><em><strong>Discard</strong></em>    </p><p>从输入 <em><strong>Multi</strong></em> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <em><strong>Exec</strong></em> 后，<em><strong>Redis</strong></em> 会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过 <em><strong>Discard</strong></em> 来放弃组队。 </p></blockquote><ul><li><p>组队成功，提交成功</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 18.23.54.png" alt="" style="zoom:50%;" /></li><li><p>放弃组队</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 18.26.06.png" alt="" style="zoom:50%;" /></li><li><p>组队中有命令错误，不会执行</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 18.29.50.png" alt="" style="zoom:50%;" /></li><li><p>组队中不报错，执行时报错</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 18.31.15.png" alt="截屏2021-10-27 18.31.15" style="zoom:50%;" /></li></ul><p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁（<em><strong>Pessimistic Lock</strong></em>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <em><strong>block</strong></em> 直到成功拿到锁。（效率低）</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁（<em><strong>Optimistic Lock</strong></em>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p><p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p><p><em><strong>Redis</strong></em> 就是利用这种 <em><strong>check-and-set</strong></em> 机制实现事务的。</p><h2 id="Watch、unwatch"><a href="#Watch、unwatch" class="headerlink" title="Watch、unwatch"></a><em>Watch、unwatch</em></h2><p>在执行 <em><strong>multi</strong></em> 之前，先执行 <em><strong>watch key1 [key2]<em><strong>，可以监视一个（或多个 ）</strong></em>key</strong></em> 。如果在事务执行之前这个 <em><strong>key</strong></em> 被其他命令所改动，那么事务将被打断。</p><p>取消 <em><strong>WATCH</strong></em> 命令对所有 <em><strong>key</strong></em> 的监视。如果在执行 <em><strong>WATCH</strong></em> 命令之后，<em><strong>EXEC</strong></em> 命令或 <em><strong>DISCARD</strong></em> 命令先被执行，那么就不需要再执行 <em><strong>UNWATCH</strong></em> 。</p><h2 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h2><ul><li><p>单独的隔离操作 </p><p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p></li><li><p>没有隔离级别的概念 </p><p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p></li><li><p>不保证原子性 </p><p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p></li></ul><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <em><strong>Snapshot</strong></em> 快照，恢复时是将快照文件直接读到内存里。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 20.31.49.png" style="zoom:50%;" /><p><em><strong>Redis</strong></em> 会单独创建一个子进程（<em><strong>fork</strong></em>）来进行持久化。</p><p>先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <em><strong>dump.rdb</strong></em>。 </p><p>整个过程中，主进程是不进行任何 <em><strong>IO</strong></em> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <em><strong>RDB</strong></em> 方式要比 <em><strong>AOF</strong></em> 方式更加的高效。</p><p><strong><em>RDB</em> 的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul><li><p>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p></li><li><p>在 <em><strong>Linux</strong></em> 程序中，<em><strong>fork()</strong></em> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <em><strong>exec</strong></em> 系统调用，出于效率考虑，<em><strong>Linux</strong></em> 中引入了 <strong>写时复制技术</strong></p></li><li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p><strong><em>dump</em> 文件名字</strong></p><p>在 <em><strong>redis.conf</strong></em> 中配置文件名称，默认为 <em><strong>dump.rdb</strong></em>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 20.41.43.png" style="zoom:50%;" /><p><strong><em>dump</em> 保存位置</strong></p><p><em><strong>rdb</strong></em> 文件的保存路径可以修改。默认为 <em><strong>Redis</strong></em> 启动时命令行所在的目录下。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-27 20.42.09.png" style="zoom:50%;" /><p><em><strong>stop-writes-on-bgsave-error</strong></em></p><p>即当 <em><strong>redis</strong></em> 无法写入磁盘，关闭 <em><strong>redis</strong></em> 的写入操作。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.30.16.png" style="zoom:50%;" /><p><em><strong>rdbcompression</strong></em></p><p>持久化的文件是否进行压缩存储。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.31.34.png" style="zoom:50%;" /><p><em><strong>rdbchecksum</strong></em></p><p>完整性的检查，即数据是否完整性、准确性。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.32.28.png" style="zoom:50%;" /><p><em><strong>save</strong></em></p><p>表示写操作的次数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">格式：<span class="hljs-keyword">save</span> 秒 写操作次数<br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.33.42.png" style="zoom:50%;" /></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>适合大规模的数据恢复；</li><li>对数据完整性和一致性要求不高更适合使用；</li><li>节省磁盘空间；</li><li>恢复速度快。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><em><strong>Fork</strong></em> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li><li>虽然 <em><strong>Redis</strong></em> 在 <em><strong>fork</strong></em> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li><li>在备份周期在一定间隔时间做一次备份，所以如果 <em><strong>Redis</strong></em> 意外 <em><strong>down</strong></em> 掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>以日志的形式来记录每个写操作（增量保存），将 <em><strong>Redis</strong></em> 执行过的所有写指令记录下来（读操作不记录）， <u>只许追加文件但不可以改写文件</u>，<em><strong>Redis</strong></em> 启动之初会读取该文件重新构建数据，换言之，如果 <em><strong>Redis</strong></em> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p><strong>执行流程</strong></p><ul><li><p>客户端的请求写命令会被 <em><strong>append</strong></em> 追加到 <em><strong>AOF</strong></em> 缓冲区内；</p></li><li><p><em><strong>AOF</strong></em> 缓冲区根据 <em><strong>AOF</strong></em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em><strong>sync</strong></em> 同步到磁盘的 <em><strong>AOF</strong></em> 文件中；</p></li><li><p><em><strong>AOF</strong></em> 文件大小超过重写策略或手动重写时，会对 <em><strong>AOF</strong></em> 文件 <em><strong>Rewrite</strong></em> 重写，压缩 <em><strong>AOF</strong></em> 文件容量；</p></li><li><p><em><strong>Redis</strong></em> 服务重启时，会重新 <em><strong>load</strong></em> 加载 <em><strong>AOF</strong></em> 文件中的写操作达到数据恢复的目的。</p></li></ul><p><em><strong>AOF</strong></em> 和 <em><strong>RDB</strong></em> 同时开启时，系统默认读取 <em><strong>AOF</strong></em> 的数据（数据不会存在丢失）</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><blockquote><p><strong><em>AOF</em> 默认不开启</strong> </p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.49.24.png" style="zoom:50%;" /><p><strong>文件名字</strong></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.49.59.png" style="zoom:50%;" /><p><strong><em>AOF</em> 同步频率设置</strong></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 13.58.07.png" style="zoom:50%;" /><p><em><strong>appendfsync always</strong></em></p><p>​    始终同步，每次 <em><strong>Redis</strong></em> 的写入都会立刻记入日志；</p><p>​    性能较差但数据完整性比较好。</p><p><em><strong>appendfsync everysec</strong></em></p><p>​    每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p><em><strong>appendfsync no</strong></em></p><p>​    <em><strong>Redis</strong></em> 不主动进行同步，把同步时机交给操作系统。</p><p> <strong><em>Rewrite</em> 压缩</strong></p><p>当 <em><strong>AOF</strong></em> 文件的大小超过所设定的阈值时，<em><strong>Redis</strong></em> 就会启动 <em><strong>AOF</strong></em> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <em><strong>bgrewriteaof</strong></em>。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 14.02.03.png" style="zoom:50%;" /></blockquote><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>备份机制更稳健，丢失数据概率更低；</li><li>可读的日志文本，通过操作 <em><strong>AOF</strong></em> 稳健，可以处理误操作。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>比起 <em><strong>RDB</strong></em> 占用更多的磁盘空间；</li><li>恢复备份速度要慢；</li><li>每次读写都同步的话，有一定的性能压力；</li><li>存在个别 <em><strong>Bug</strong></em>，造成不能恢复。</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用 <em><strong>RDB</strong></em>。</p><p>不建议单独用 <em><strong>AOF</strong></em>，因为可能会出现 <em><strong>Bug</strong></em>。</p><p>如果只是做纯内存缓存，可以都不用。</p></blockquote><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 <em><strong>master/slaver</strong></em> 机制，<em><strong>Master</strong></em> 以写为主，<em><strong>Slaver</strong></em> 以读为主。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 14.12.36.png" style="zoom:50%;" /><ol><li>读写分离，性能扩展</li><li>容灾快速恢复</li><li>一主多从！</li></ol><h2 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h2><ol><li>创建文件目录</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/opt/</span>etc<br></code></pre></td></tr></table></figure><ol start="2"><li>将 <em><strong>redis.conf</strong></em> 复制到当前目录</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp <span class="hljs-regexp">/etc/</span>redis.conf <span class="hljs-regexp">/opt/</span>etc/<br></code></pre></td></tr></table></figure><ol start="3"><li>创建 3 个 <em><strong>redis.conf</strong></em> 配置文件</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis6379.<span class="hljs-keyword">conf</span><br>redis6380.<span class="hljs-keyword">conf</span><br>redis6381.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># redis6379.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br><br><span class="hljs-comment"># redis6380.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6380.pid<br>port 6380<br>dbfilename dump6380.rdb<br><br><span class="hljs-comment"># redis6381.conf</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6381.pid<br>port 6381<br>dbfilename dump6381.rdb<br></code></pre></td></tr></table></figure><ol start="4"><li>启动 3 台 <em><strong>redis</strong></em> 服务器</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 14.57.37.png" alt="" style="zoom:50%;" /><ol start="5"><li>查看主机运行情况</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">info</span> <span class="hljs-keyword">replication</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-10-30%2015.00.10-20211031152900224.png" style="zoom:50%;" /><ol start="6"><li>配从不配主</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof  &lt;ip&gt;&lt;port&gt;<br><span class="hljs-comment"># 成为某个实例的从服务器</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 15.03.22.png" style="zoom:50%;" /><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 15.03.40.png" alt="截屏2021-10-30 15.03.40" style="zoom:50%;" /><ol start="7"><li>再次查看主机运行情况</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 15.04.41.png" style="zoom:50%;" /><p>成功搭建。</p><h2 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h2><blockquote><p>主机 <em><strong>6379</strong></em>，从机 <em><strong>6380</strong></em> 和 <em><strong>6381</strong></em>。</p><ol><li>假设从机 <em><strong>6380</strong></em> 挂掉。</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">当<span class="hljs-number">6380</span>重启后，<span class="hljs-number">6380</span>不再是<span class="hljs-number">6379</span>的从机，而是作为新的<span class="hljs-literal">master</span>；<br>当再次把<span class="hljs-number">6380</span>作为<span class="hljs-number">6379</span>的从机加入后，从机会把数据从头到尾复制。<br></code></pre></td></tr></table></figure><ol start="2"><li>假设主机 <em><strong>6379</strong></em> 挂掉。</li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">6380和6381</span>仍然是<span class="hljs-number">6379</span>的从机，不会做任何事；<br>当<span class="hljs-number">6379</span>重启后，既然是主服务器。<br></code></pre></td></tr></table></figure></blockquote><h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 16.38.15.png" style="zoom:50%;" /><p>上一个 <em><strong>slave</strong></em> 可以是下一个 <em><strong>slave</strong></em> 的 <em><strong>master</strong></em>，<em><strong>slave</strong></em> 同样可以接收其他 <em><strong>slave</strong></em>的连接和同步请求，那么该 <em><strong>slave</strong></em> 作为了链条中下一个的 <em><strong>master</strong></em>，可以有效减轻 <em><strong>master</strong></em> 的写压力，去中心化降低风险。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span><br></code></pre></td></tr></table></figure><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p><p>当某个 <em><strong>slave</strong></em> 宕机，后面的 <em><strong>slave</strong></em> 都没法备份。</p><p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p><h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><p>当一个 <em><strong>master</strong></em> 宕机后，后面的 <em><strong>slave</strong></em> 可以立刻升为 <em><strong>master</strong></em>，其后面的 <em><strong>slave</strong></em> 不用做任何修改。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one<br></code></pre></td></tr></table></figure><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><ol><li>创建 <em><strong>sentinel.conf</strong></em> 文件</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/opt/</span>etc/sentinel.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>配置哨兵</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sentinel monitor mymaster 172.16.88.168 6379 1<br><br><span class="hljs-comment"># mymaster：监控对象起的服务器名称</span><br><span class="hljs-comment"># 1：至少有多少个哨兵同意迁移的数量。 </span><br></code></pre></td></tr></table></figure><ol start="3"><li>启动哨兵</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-sentinel  <span class="hljs-regexp">/opt/</span>etc/sentinel.conf <br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 16.53.08.png" alt="" style="zoom:50%;" /><p>主机挂掉，会从机选举中产生新的主机。选举的规则。</p><h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><ul><li><p>根据优先级别，<em><strong>slave-priority/replica-priority</strong></em>，优先选择优先级靠前的。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 17.02.50.png" alt="" style="zoom:50%;" /></li><li><p>根据偏移量，优先选择偏移量大的。</p></li><li><p>根据 <em><strong>runid</strong></em>，优先选择最小的服务。</p></li></ul><h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在 <em><strong>master</strong></em> 上操作，然后同步更新到 <em><strong>slave</strong></em> 上，所以从 <em><strong>master</strong></em> 同步到 <em><strong>slave</strong></em> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<em><strong>slave</strong></em> 机器数量的增加也会使这个问题更加严重。</p><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><ul><li><p><em><strong>slave</strong></em> 启动成功连接到 <em><strong>master</strong></em> 后会发送一个 <em><strong>sync</strong></em> 命令（同步命令）。</p></li><li><p><em><strong>master</strong></em> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<em><strong>master</strong></em> 将传送整个数据文件（<em><strong>rdb</strong></em>）到 <em><strong>slave</strong></em>，以完成一次完全同步。</p></li><li><p>当主服务进行写操作后，和从服务器进行数据同步。</p></li><li><p>全量复制：而 <em><strong>slave</strong></em> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：<em><strong>master</strong></em> 继续将新的所有收集到的修改命令依次传给 <em><strong>slave</strong></em>，完成同步。</p></li><li><p>只要是重新连接 <em><strong>master</strong></em>，一次完全同步（全量复制）将被自动执行。</p></li></ul><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>容量不够，<em><strong>redis</strong></em> 如何进行扩容？</p><p>并发写操作， <em><strong>redis</strong></em> 如何分摊？</p><p>主从模式，薪火相传模式，主机宕机，导致 <em><strong>ip</strong></em> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>解决方法：</p><ul><li><p>代理主机（ <em><strong>之前</strong></em> ）</p><p>![](<a href="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-10-30">https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30</a> 17.19.15.png)</p></li><li><p>无中心化集群配置（ <em><strong>redis3.0</strong></em> ）</p></li></ul><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 17.21.46.png" style="zoom:50%;" /><p><em><strong>Redis</strong></em> 集群实现了对 <em><strong>Redis</strong></em> 的水平扩容，即启动 <em><strong>N</strong></em> 个 <em><strong>Redis</strong></em> 节点，将整个数据库分布存储在这 <em><strong>N</strong></em> 个节点中，每个节点存储总数据的 <em><strong>1/N</strong></em> 。</p><p><em><strong>Redis</strong></em> 集群通过分区（<em><strong>partition</strong></em>）来提供一定程度的可用性（<em><strong>availability</strong></em>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><h2 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 <em>Redis</em> 集群</h2><ol><li>创建配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以redis6379.conf为例</span><br>include /opt/etc/redis.conf<br>pidfile /var/run/redis_6379.pid <span class="hljs-comment"># 更改</span><br>port 6379 <span class="hljs-comment"># 更改</span><br>dbfilename dump6379.rdb <span class="hljs-comment"># 更改</span><br>cluster-enabled yes <span class="hljs-comment"># 打开集群模式</span><br>cluster-config-file nodes-6379.conf <span class="hljs-comment"># 设置节点配置文件名称，需要更改</span><br>cluster-node-timeout 15000 <span class="hljs-comment"># 设置节点失联事件，超过该时间（ms），集群自动进行主从切换</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 20.02.32.png" style="zoom:50%;" /><ol start="2"><li>启动</li></ol><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-30 20.08.04.png" alt="" style="zoom:50%;" /><ol start="3"><li>将 6 个节点合成一个集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 组合之前请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.09.52.png" style="zoom:50%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入redis安装目录</span><br>/opt/redis-6.2.6/src<br><br><span class="hljs-comment"># 执行</span><br>redis-cli --cluster create --cluster-replicas 1 172.16.88.168:6379 172.16.88.168:6380 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391<br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.12.16.png" style="zoom:50%;" /><ol start="4"><li>采用集群策略连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -c -p PORT<br>cluster nodes <span class="hljs-comment"># 命令查看集群信息</span><br></code></pre></td></tr></table></figure><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.15.31.png" style="zoom:50%;" /><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="redis-cluster-如何分配这六个节点"><a href="#redis-cluster-如何分配这六个节点" class="headerlink" title="redis cluster 如何分配这六个节点?"></a><em>redis cluster</em> 如何分配这六个节点?</h3><blockquote><p>一个集群至少要有三个主节点。</p><p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的 <em><strong>IP</strong></em> 地址，每个从库和主库不在一个 <em><strong>IP</strong></em> 地址上。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.30.26.png" style="zoom:50%;" /></blockquote><h3 id="什么是-slots？"><a href="#什么是-slots？" class="headerlink" title="什么是 slots？"></a>什么是 <em>slots</em>？</h3><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.21.25.png" alt="" style="zoom:50%;" /><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.15.31.png" style="zoom:50%;" /><blockquote><p>一个 <em><strong>Redis</strong></em> 集群包含 <em><strong>16384</strong></em> 个插槽（<em><strong>hash slot</strong></em>）， 数据库中的每个键都属于这 <em><strong>16384</strong></em> 个插槽的其中一个。</p><p>集群使用公式 <em><strong>CRC16(key) % 16384</strong></em> 来计算键 <em><strong>key</strong></em> 属于哪个槽， 其中 <em><strong>CRC16(key)</strong></em> 语句用于计算键 <em><strong>key</strong></em> 的 <em><strong>CRC16</strong></em> 校验和 。</p><p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p><ul><li>节点 <em><strong>A</strong></em> 负责处理 <em><strong>0</strong></em> 号至 <em><strong>5460</strong></em> 号插槽。</li><li>节点 <em><strong>B</strong></em> 负责处理 <em><strong>5461</strong></em> 号至 <em><strong>10922</strong></em> 号插槽。</li><li>节点 <em><strong>C</strong></em> 负责处理 <em><strong>10923</strong></em> 号至 <em><strong>16383</strong></em> 号插槽。</li></ul></blockquote><h3 id="如何在集群中录入值？"><a href="#如何在集群中录入值？" class="headerlink" title="如何在集群中录入值？"></a>如何在集群中录入值？</h3><blockquote><p>在 <em><strong>redis-cli</strong></em> 每次录入、查询键值，<em><strong>redis</strong></em> 都会计算出该 <em><strong>key</strong></em> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<em><strong>redis</strong></em> 会报错，并告知应前往的 <em><strong>redis</strong></em> 实例地址和端口。</p><p><em><strong>redis-cli</strong></em> 客户端提供了 <em><strong>–c</strong></em> 参数实现自动重定向。</p><p>例如 <em><strong>redis-cli -c –p 6379</strong></em> 登入后，再录入、查询键值对可以自动重定向。</p></blockquote><h3 id="如何查询集群中的值？"><a href="#如何查询集群中的值？" class="headerlink" title="如何查询集群中的值？"></a>如何查询集群中的值？</h3><blockquote><p>每个主机只能查询自己范围内部的插槽。</p><p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <em><strong>key</strong></em> 的 **<em>slot</em> **。</p><p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <em><strong>slot</strong></em> 是否有值。</p><p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <em><strong>count</strong></em> 个 <em><strong>slot</strong></em> 槽中的键。</p></blockquote><h3 id="故障恢复？"><a href="#故障恢复？" class="headerlink" title="故障恢复？"></a>故障恢复？</h3><blockquote><p>如果主节点下线？从节点能否自动升为主节点？注意：<em><strong>15</strong></em> 秒超时。</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 14.42.26.png" alt="" style="zoom:50%;" /><ul><li>当 <em><strong>6379</strong></em> 挂掉后，<em><strong>6389</strong></em> 成为新的主机。</li></ul><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><ul><li>当 <em><strong>6379</strong></em> 重启后，<em><strong>6379</strong></em> 成为 <em><strong>6389</strong></em> 的从机。</li></ul><p>如果所有某一段插槽的主从节点都宕掉，<em><strong>redis</strong></em> 服务是否还能继续?</p><ul><li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage=yes</strong></em>，那么 ，整个集群都挂掉。</li><li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage=no</strong></em>，那么，该插槽数据全都不能使用，也无法存储。</li></ul><p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p></blockquote><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>实现扩容；</li><li>分摊压力；</li><li>无中心配置相对简单。</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>多键操作是不被支持的；</li><li>多键的 <em><strong>Redis</strong></em> 事务是不被支持的。<em><strong>lua</strong></em> 脚本不被支持；</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<em><strong>redis cluster</strong></em>，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul><h1 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h1><p>即 <em><strong>Java</strong></em> 操作 <em><strong>Redis</strong></em>。</p><ol><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>连接 <em><strong>Redis</strong></em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.57.101&quot;</span>, <span class="hljs-number">6379</span>);<br>    String pong = jedis.ping();<br>    System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span> + pong);<br>    jedis.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><em><strong>Key</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>System.out.println(key);<br>&#125;<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure><p><em><strong>String</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br></code></pre></td></tr></table></figure><p><em><strong>List</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String element : list) &#123;<br>System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>Set</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order04&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br><span class="hljs-keyword">for</span> (String order : smembers) &#123;<br>System.out.println(order);<br>&#125;<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure><p><em><strong>Hash</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br><span class="hljs-keyword">for</span> (String element : result) &#123;<br>System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>zset</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">80d</span>, <span class="hljs-string">&quot;w5&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">70d</span>, <span class="hljs-string">&quot;z6&quot;</span>);<br><br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String e : zrange) &#123;<br>System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="Jedis-主从复制"><a href="#Jedis-主从复制" class="headerlink" title="Jedis 主从复制"></a><em>Jedis</em> 主从复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="hljs-keyword">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Jedis <span class="hljs-title">getJedisFromSentinel</span><span class="hljs-params">()</span></span>&#123;<br><br>  <span class="hljs-keyword">if</span>(jedisSentinelPool==<span class="hljs-keyword">null</span>)&#123;<br>    Set&lt;String&gt; sentinelSet=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    sentinelSet.add(<span class="hljs-string">&quot;172.16.88.168:26379&quot;</span>); <span class="hljs-comment">// 端口为sentinal</span><br>    JedisPoolConfig jedisPoolConfig =<span class="hljs-keyword">new</span> JedisPoolConfig();<br>    jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>); <span class="hljs-comment">// 最大可用连接数</span><br>    jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">// 最大闲置连接数</span><br>    jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">// 最小闲置连接数</span><br>    jedisPoolConfig.setBlockWhenExhausted(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 连接耗尽是否等待</span><br>    jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 等待时间</span><br>    jedisPoolConfig.setTestOnBorrow(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 取连接的时候进行测试</span><br><br>    jedisSentinelPool=<span class="hljs-keyword">new</span> JedisSentinelPool(<span class="hljs-string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig); <span class="hljs-comment">// 服务主机名</span><br>    <span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisClusterTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>     Set&lt;HostAndPort&gt;set =<span class="hljs-keyword">new</span> HashSet&lt;HostAndPort&gt;();<br>     set.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">&quot;172.16.88.168&quot;</span>,<span class="hljs-number">6379</span>)); <span class="hljs-comment">// 任何一个端口</span><br>     JedisCluster jedisCluster = <span class="hljs-keyword">new</span> JedisCluster(set);<br>     jedisCluster.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>     System.out.println(jedisCluster.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><ol><li>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件配置 <em><strong>Redis</strong></em></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#Redis服务器地址</span><br><span class="hljs-meta">spring.redis.host</span>= <span class="hljs-string">ip</span><br><span class="hljs-comment">#Redis服务器连接端口</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-comment">#Redis数据库索引（默认为0）</span><br><span class="hljs-meta">spring.redis.database</span>= <span class="hljs-string">0</span><br><span class="hljs-comment">#连接超时时间（毫秒）</span><br><span class="hljs-meta">spring.redis.timeout</span>=<span class="hljs-string">1800000</span><br><span class="hljs-comment">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="hljs-meta">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">20</span><br><span class="hljs-comment">#最大阻塞等待时间(负数表示没限制)</span><br><span class="hljs-meta">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment">#连接池中的最大空闲连接</span><br><span class="hljs-meta">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment">#连接池中的最小空闲连接</span><br><span class="hljs-meta">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><ol start="3"><li><em><strong>Redis</strong></em> 配置类（需要继承 <em><strong>CachingConfigurerSupport</strong></em>）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br><span class="hljs-comment">// key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br><span class="hljs-comment">// value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br><span class="hljs-comment">// value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br><span class="hljs-comment">// 解决查询缓存转换异常的问题</span><br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br><span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        RedisCacheConfiguration config = <br>          RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 15.02.58.png" style="zoom:50%;" /><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><em><strong>key</strong></em> 对应的数据在数据源并不存在，每次针对此 <em><strong>key</strong></em> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p><p>比如用一个不存在的用户 <em><strong>id</strong></em> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>造成：</p><ol><li>应用服务器压力变大。</li><li><em><strong>redis</strong></em> 命中率下降 $\longrightarrow$ 查询数据库 。</li></ol><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>对空值缓存</strong></p><p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<em><strong>null</strong></em>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单）：</strong></p><p>使用 <em><strong>bitmaps</strong></em> 类型定义一个可以访问的名单，名单 <em><strong>id</strong></em> 作为 <em><strong>bitmaps</strong></em> 的偏移量，每次访问和 <em><strong>bitmap</strong></em> 里面的 <em><strong>id</strong></em> 进行比较，如果访问 <em><strong>id</strong></em> 不在 <em><strong>bitmaps</strong></em> 里面，进行拦截，则不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong></p><p>布隆过滤器（<em><strong>Bloom Filter</strong></em>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>将所有可能存在的数据哈希到一个足够大的 <em><strong>bitmaps</strong></em> 中，一个一定不存在的数据会被这个 <em><strong>bitmaps</strong></em> 拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 <em><strong>Redis</strong></em> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/截屏2021-10-31 15.18.09.png" style="zoom:50%;" /><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p><ol><li>数据库访问压力瞬间增大。</li><li><em><strong>redis</strong></em> 中没有出现大量 <em><strong>key</strong></em> 过期，<em><strong>redis</strong></em> 正常运行。</li><li>（即某个经常访问的 <em><strong>key</strong></em> 过期，突然有大量访问这个数据）</li></ol><h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p>预先设置热门数据</p><p>在 <em><strong>redis</strong></em> 高峰访问之前，把一些热门数据提前存入到 <em><strong>redis</strong></em> 里面，加大这些热门数据 <em><strong>key</strong></em> 的时长。</p></li><li><p>实时调整</p><p>现场监控哪些数据热门，实时调整 <em><strong>key</strong></em> 的过期时长。</p></li><li><p>使用锁</p></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 <em><strong>key</strong></em> 缓存，前者则是某一个 <em><strong>key</strong></em>。</p><ol><li>数据库压力变大。</li><li>即极少的时间段，查询大量 <em><strong>key</strong></em> 的集中过期情况。</li></ol><h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>构建多级缓存架构</strong></p><p><em><strong>nginx</strong></em> 缓存 + <em><strong>redis</strong></em> 缓存 + 其他缓存（<em><strong>ehcache</strong></em>等）</p></li><li><p><strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p></li><li><p><strong>设置过期标志更新缓存：</strong></p><p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <em><strong>key</strong></em> 的缓存。</p></li><li><p><strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>$###################\space to \space do\space ###################$</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1Rv41177Af">尚硅谷-王老师</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>中间件</category>
      
      <category>缓存</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2021/08/19/springmvc/"/>
    <url>/2021/08/19/springmvc/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分。</p><ul><li><p>M：Model，模型层</p><p>指工程中的 JavaBean，作用是处理数据。</p><p>JavaBean 分为两类：</p><ul><li>一类称为实体类 Bean：专门存储业务数据的，如 Student、User 等。</li><li>一类称为业务处理  Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul></li><li><p>V：View，视图层</p><p>指工程中的 html 或 jsp 等页面，作用是与用户进行交互，展示数据。</p></li><li><p>C：Controller，控制层</p><p>指工程中的 servlet，作用是接收请求和响应浏览器。</p></li></ul><blockquote><p><strong>工作流程</strong><br>用户通过视图层发送请求到服务器，在服务器中请求被 Controller 接收，Controller 调用相应的 Model 层处理请求，处理完毕将结果返回到 Controller，Controller 再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p></blockquote><h3 id="SpringMVC-1"><a href="#SpringMVC-1" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。</p><p><strong>特点</strong></p><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接；</li><li><strong>基于原生的 Servlet</strong>，通过了功能强大的<strong>前端控制器 DispatcherServlet</strong>，对请求和响应进行统一处理；</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong>；</li><li><strong>代码清新简洁</strong>，大幅度提升开发效率；</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可；</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求。</li></ul><h2 id="SpringMVC简单入门"><a href="#SpringMVC简单入门" class="headerlink" title="SpringMVC简单入门"></a>SpringMVC简单入门</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p>开发步骤：</p><ol><li>导入 SpringMVC 依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- Spring --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- SpringMVC --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Servlet --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Jsp --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>web.xml</code> 中配置 SpringMVC 核心控制器 <strong><u>DispathcerServlet</u></strong> ，SpringMVC 的配置文件默认位于 WEB-INF 下，默认名称为 &lt;servlet-name&gt;-servlet.xml。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringMVC前端控制器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span><br><span class="hljs-comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span><br><span class="hljs-comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><br><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><br><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>关于 &lt;url-pattern&gt;/&lt;/url-pattern&gt;</p><ul><li>/ 所匹配的请求可以是 /login 或 .html 或 .js 或 .css 方式的请求路径，但是 / 不能匹配 .jsp 请求路径的请求。因此就可以避免在访问 jsp 页面时，该请求被 <strong><u>DispatcherServlet</u></strong> 处理，从而找不到相应的页面。</li><li>/* 则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用 /* 的写法。</li></ul></blockquote><ol start="3"><li>创建 Controller 类和视图页面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;quick method running...&quot;</span>);        <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>使用注解配置 Controller 类中业务方法的映射地址</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>配置SpringMVC核心文件 <code>spring-mvc.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 自动扫描包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.tsuiraku.controller&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><br>                        <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><br>                        <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">     处理静态资源，例如html、js、css、jpg</span><br><span class="hljs-comment">     若只设置该标签，则只能访问静态资源，其他请求则无法访问</span><br><span class="hljs-comment">     此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 开启mvc注解驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultCharset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6"><li>客户端发起请求测试</li></ol><p><strong>流程演示</strong></p><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-08-19%2019.16.34.png"></p><h1 id="SpringMVC的注解解析"><a href="#SpringMVC的注解解析" class="headerlink" title="SpringMVC的注解解析"></a>SpringMVC的注解解析</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>作用：用于建立请求 URL 和处理请求方法之间的对应关系。</p><p>位置</p><ul><li><p>类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录；</p></li><li><p>方法上，请求 URL 的第二级访问目录，与类上的使用 @ReqquestMapping 标注的一级目录一起组成访问虚拟路径。</p></li></ul><p>属性</p><ul><li>**<u>value</u>**：用于指定请求的 URL。它和 path 属性的作用是一样的；</li><li>**<u>method</u>**：用于指定请求的方式，<code>method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</code>；（匹配不成功 —&gt; 405）</li><li>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。（匹配不成功 —&gt; 400）</li><li>headers：属性通过请求的请求头信息匹配请求映射。（匹配不成功 —&gt; 404）</li></ul><blockquote><p><u><strong>value</strong></u></p><p>支持 ant 风格的路径</p><ul><li>？：表示任意的单个字符</li><li>*：表示任意的0个或多个字符*</li><li>**：表示任意的一层或多层目录</li></ul><p>支持路径中的占位符</p><ul><li><p>原始方式：/deleteUser?id=1</p></li><li><p>Rest方式：/deleteUser/1</p></li></ul><p><strong><u>method</u></strong></p><ol><li><p>对于处理指定请求方式的控制器方法，SpringMVC 中提供了 @RequestMapping 的派生注解</p><ul><li><p>处理 get 请求的映射–&gt;@GetMapping</p></li><li><p>处理 post 请求的映射–&gt;@PostMapping</p></li><li><p>处理 put 请求的映射–&gt;@PutMapping</p></li><li><p>处理 delete 请求的映射–&gt;@DeleteMapping</p></li></ul></li><li><p>常用的请求方式有 <strong><u>get、post、put、delete</u></strong></p><ul><li><p>但是目前浏览器只支持 get 和 post ，若在 form 表单提交时，为 method 设置了其他请求方式的字符串（put或delete），则按照默认的请求方式 get 处理；</p></li><li><p>若要发送 put 和 delete 请求，则需要通过 Spring 提供的过滤器 **<u>HiddenHttpMethodFilter</u>**，在RESTful部分会讲到。</p></li></ul></li></ol><p><strong>param</strong></p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数；</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数；</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value；</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value。</p><p><strong>headers</strong></p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息；</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息；</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value；</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value。</p></blockquote><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a><a href="#@RequestParam%E6%B3%A8%E8%A7%A3">@RequestParam</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a><a href="#@RequestHeader%E6%B3%A8%E8%A7%A3">@RequestHeader</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a><a href="#@CookieValue%E6%B3%A8%E8%A7%A3">@CookieValue</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a><a href="#PathVariable%E6%B3%A8%E8%A7%A3">@PathVariable</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a><a href="#@RequestBody%E6%B3%A8%E8%A7%A3">@RequestBody</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a><a href="#@RequestBody%E6%B3%A8%E8%A7%A3">@ResponseBody</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a><a href="#@RestController%E6%B3%A8%E8%A7%A3">@RestController</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a><a href="#@ControllerAdvice%E6%B3%A8%E8%A7%A3">@ControllerAdvice</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a><a href="#@ExceptionHandler%E6%B3%A8%E8%A7%A3">@ExceptionHandler</a></h2><p class="note note-info">点击标题跳转到详情</p><h1 id="SpringMVC-xml"><a href="#SpringMVC-xml" class="headerlink" title="SpringMVC.xml"></a>SpringMVC.xml</h1><h2 id="Controller注解扫描"><a href="#Controller注解扫描" class="headerlink" title="@Controller注解扫描"></a>@Controller注解扫描</h2><p><strong><u>&lt;context:componet-scan base-pacakage=”com.xxx.xxx”&gt; &lt;/context:componet-scan&gt;</u></strong></p><h2 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a><u>注解驱动</u></h2><p><strong><u>&lt;mvc:annotation-driven/&gt;</u></strong></p><p>开启 mvc 注解驱动。如果不开启注解驱动，那么所有的请求将会被默认 Servlet 处理。</p><p>搭配：**<u>&lt;mvc:default-servlet-handler&gt;</u>**（开启默认 Servlet，开启对静态资源的访问）。</p><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a><a href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8(ViewResolver)">视图解析器</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="文件解析器"><a href="#文件解析器" class="headerlink" title="文件解析器"></a>文件解析器</h2><p><strong><u>multipartResolver</u></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 必须通过文件解析器的解析才能将文件转换为MultipartFile对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><a href="#SpringMVC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a></h2><p class="note note-info">点击标题跳转到详情</p><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a><a href="#SpringMVC%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8">异常处理器</a></h2><p class="note note-info">点击标题跳转到详情</p><h1 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h1><blockquote><p>客户端请求参数的格式是：<code>name=value&amp;name=value…</code></p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC 可以接收如下类型的参数</p><ul><li>基本类型参数</li><li>POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul></blockquote><h2 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h2><p class="note note-warning">不建议使用</p><p>将 HttpServletRequest 作为控制器方法的形参，此时 HttpServletRequest 类型的参数表示封装了当前请求的请求报文的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="控制器方法的形参"><a href="#控制器方法的形参" class="headerlink" title="控制器方法的形参"></a>控制器方法的形参</h2><p>在控制器方法的形参位置，**<u>设置和请求参数同名的形参</u>**，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet 中就会将请求参数赋值给相应的形参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(String username, String password)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数；</li><li>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据；</li><li>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果。</li></ul><h2 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h2><p> <span id = "@RequestParam注解"></span></p><p>当请求的参数名称与 Controller 的业务方法参数名称不一致时，就需要通过 @RequestParam 注解显示的绑定。</p><p>@RequestParam 是将请求参数和控制器方法的形参创建映射关系。</p><blockquote><p><strong>value</strong>：指定为形参赋值的请求参数的参数名；</p><p><strong>required</strong>：设置是否必须传输此请求参数，默认值为 true；</p><ul><li>若 <code>required=true</code> 时，则当前请求必须传输 value 所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue 属性，则页面报错400：<code>Required String parameter &#39;xxx&#39; is not present</code>；</li><li>若 <code>required=false</code>，则当前请求不是必须传输 value 所指定的请求参数，若没有传输，则注解所标识的形参的值为 null。</li></ul><p><strong>defaultValue</strong>：不管 required 属性值为 true 或 false ，当 value 所指定的请求参数没有传输或传输的值为空字符串时，则使用默认值为形参赋值。</p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;  <br>  &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;br&gt;  <br>  &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;&lt;br&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTest</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span>String username)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  System.out.println(username);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="@RequestHeader注解"></a>@RequestHeader注解</h2><p> <span id = "@RequestHeader注解"></span></p><p>@RequestHeader 是将请求头信息和控制器方法的形参创建映射关系。    </p><blockquote><ul><li><strong>value</strong>：请求头的名称；</li><li><strong>required</strong>：是否必须携带此请求头。</li><li><strong>defaultValue</strong>。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParam</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  // 获取请求头 User-Agent </span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-meta">@RequestHeader(value = &quot;User-Agent&quot;, required = false)</span> String headerValue)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="CookieValue注解"><a href="#CookieValue注解" class="headerlink" title="@CookieValue注解"></a>@CookieValue注解</h2><p> <span id = "@CookieValue注解"></span></p><p>@CookieValue 是将 cookie 数据和控制器方法的形参创建映射关系。使用 @CookieValue 可以获得指定Cookie的值。</p><blockquote><ul><li><strong>value</strong>：指定 cookie 的名称；</li><li><strong>required</strong>：是否必须携带此 cookie；</li><li><strong>defaultValue</strong>。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParam</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;JSESSIONID&quot;, required = false)</span> String headerValue)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="POJO类型"><a href="#POJO类型" class="headerlink" title="POJO类型"></a>POJO类型</h2><p>可以在控制器方法的形参位置设置一个实体类类型的形参。Controller 中的业务方法的 POJO 参数的属性名与请求参数的 name 一致，参数值会自动映射匹配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">User</span><span class="hljs-params">()</span></span>&#123;  <br>  <span class="hljs-keyword">private</span> Integer id;  <br>  <span class="hljs-keyword">private</span> String username;  <br>  <span class="hljs-keyword">private</span> String password;  <br>  <span class="hljs-keyword">private</span> Integer age;  <br>  <span class="hljs-keyword">private</span> String sex; <br>  <span class="hljs-keyword">private</span> String email; <br>  <br>  <span class="hljs-comment">// 生成 set/get 方法</span><br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testParam</span><span class="hljs-params">(User user)</span> </span>&#123;  <br>  System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h2><p>获得集合参数时，要将集合参数包装到一个 POJO 中才可以。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[0].username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[0].age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[1].username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userList[1].age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class Vo&#123;  <br>  <span class="hljs-keyword">private</span> List&lt;User&gt; userList;  <br>  <span class="hljs-comment">// set/get</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTest</span><span class="hljs-params">(Vo vo)</span> </span>&#123;<br>  System.out.println(vo.getUserList());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="请求参数的乱码问题"><a href="#请求参数的乱码问题" class="headerlink" title="请求参数的乱码问题"></a>请求参数的乱码问题</h2><h3 id="CharacterEncodingFilter"><a href="#CharacterEncodingFilter" class="headerlink" title="CharacterEncodingFilter"></a><u><strong>CharacterEncodingFilter</strong></u></h3><p>当 <u><strong>get</strong></u> 请求，可以在 tomcat 中 server.xml 中修改配置。</p><p>当 <strong><u>post</u></strong> 请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。使用 SpringMVC 提供的编码过滤器 CharacterEncodingFilter。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置CharacterEncodingFilter --&gt;</span><br><span class="hljs-comment">&lt;!-- web.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>SpringMVC 中处理编码的过滤器一定要配置到其他过滤器之前，否则无效。</li></ul><h1 id="SpringMVC的域对象共享数据"><a href="#SpringMVC的域对象共享数据" class="headerlink" title="SpringMVC的域对象共享数据"></a>SpringMVC的域对象共享数据</h1><h2 id="向request域对象中共享数据"><a href="#向request域对象中共享数据" class="headerlink" title="向request域对象中共享数据"></a>向request域对象中共享数据</h2><p>根据共享数据的键获取数据。</p><h3 id="ServletAPI-1"><a href="#ServletAPI-1" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><p class="note note-warning">不建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testServletAPI&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testServletAPI</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello servletAPI&quot;</span>); <span class="hljs-comment">// 设置域共享数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p class="note note-primary">重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">testModelAndView</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Model：主要用于向请求域共享数据</span><br><span class="hljs-comment">     * View：主要用于设置视图，实现页面跳转</span><br><span class="hljs-comment">     */</span><br>    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();<br>    <span class="hljs-comment">// 向请求域共享数据</span><br>    mav.addObject(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello ModelAndView&quot;</span>);<br>    <span class="hljs-comment">// 设置视图，实现页面跳转</span><br>    mav.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> mav;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModel&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModel</span><span class="hljs-params">(Model model)</span></span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello Model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testMap&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>&#123;<br>    map.put(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello Map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ModelMap"><a href="#ModelMap" class="headerlink" title="ModelMap"></a>ModelMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelMap&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModelMap</span><span class="hljs-params">(ModelMap modelMap)</span></span>&#123;<br>    modelMap.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello ModelMap&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Model-amp-ModelMap-amp-Map的关系"><a href="#Model-amp-ModelMap-amp-Map的关系" class="headerlink" title="Model &amp; ModelMap &amp; Map的关系"></a>Model &amp; ModelMap &amp; Map的关系</h2><p>Model、ModelMap、Map 类型的参数其实本质上都是 <strong><u>BindingAwareModelMap</u></strong> 类型的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 继承关系</span><br>public interface <span class="hljs-type">Model</span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap&lt;String</span>, <span class="hljs-title">Object&gt;</span> </span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendedModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ModelMap</span> <span class="hljs-title">implements</span> <span class="hljs-title">Model</span> </span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindingAwareModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExtendedModelMap</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><p>根据 session.key 获取数据。</p><h3 id="ServletAPI-2"><a href="#ServletAPI-2" class="headerlink" title="ServletAPI"></a>ServletAPI</h3><p class="note note-info">建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testSession&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testSession</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;testSessionScope&quot;</span>, <span class="hljs-string">&quot;hello session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="向application域共享数据"><a href="#向application域共享数据" class="headerlink" title="向application域共享数据"></a>向application域共享数据</h2><p>对应整个工程域范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testApplication&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testApplication</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>  <span class="hljs-comment">// ServletContext</span><br>  ServletContext application = session.getServletContext();<br>    application.setAttribute(<span class="hljs-string">&quot;testApplicationScope&quot;</span>, <span class="hljs-string">&quot;hello application&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h1><p>SpringMVC 中的视图是 View 接口，视图的作用渲染数据，将模型Model中的数据展示给用户。</p><p>SpringMVC 视图的种类很多，默认有转发视图（InternalResourceView）和重定向视图（RedirectView）。</p><p>若使用的视图技术为 Thymeleaf，在 SpringMVC 的配置文件中配置了 Thymeleaf 的视图解析器，由此视图解析器解析之后所得到的是 ThymeleafView。</p><h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被 SpringMVC 配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="hljs-comment">&lt;!-- ThymeleafViewResolver --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br><br>                      <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br><br>                      <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h2><p><strong><u>InternalResourceView</u></strong></p><p>当 Controller 方法中所设置的视图名称以 <code>forward:</code> 为前缀时，创建InternalResourceView 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>forward:</code> 去掉，剩余部分作为最终路径通过转发的方式实现跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/testForward&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testForward</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h2><p><strong><u>RedirectView</u></strong></p><p>当 Controller 方法中所设置的视图名称以 <code>redirect:</code> 为前缀时，创建 RedirectView 视图，此时的视图名称不会被 SpringMVC 配置文件中所配置的视图解析器解析，而是会将前缀 <code>redirect:</code> 去掉，剩余部分作为最终路径通过重定向的方式实现跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/testRedirect&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedirect</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><p><strong><u>view-controller</u></strong></p><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用 view-controller 标签进行表示。</p><p>当 SpringMVC 中设置任何一个 view-controller 时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC 的核心配置文件中设置开启 mvc 注解驱动的标签：**<u>&lt;mvc:annotation-driven /&gt;</u>**。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">path：设置处理的请求地址</span><br><span class="hljs-comment">view-name：设置请求地址所对应的视图名称</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-comment">&lt;!-- springMVC.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testView&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="视图解析器（ViewResolver）"><a href="#视图解析器（ViewResolver）" class="headerlink" title="视图解析器（ViewResolver）"></a>视图解析器（ViewResolver）</h2><p><span id="视图解析器(ViewResolver)"></span></p><p><strong><u>ViewResolver</u></strong></p><p><strong><u>InternalResourceViewResolver</u></strong></p><p>该解析器的默认设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">REDIRECT_URL_PREFIX = <span class="hljs-string">&quot;redirect:&quot;</span>  --重定向前缀<br>FORWARD_URL_PREFIX = <span class="hljs-string">&quot;forward:&quot;</span>    --转发前缀（默认值）<br>prefix = <span class="hljs-string">&quot;&quot;</span>;     --视图名称前缀<br>suffix = <span class="hljs-string">&quot;&quot;</span>;     --视图名称后缀<br></code></pre></td></tr></table></figure><p><code>springMVC.xml</code> 配置中通过属性注入的方式修改视图的的前后缀</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置内部资源视图解析器 --&gt;</span><br><span class="hljs-comment">&lt;!-- 解析JSP视图 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><p><strong>资源</strong></p><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个 URI 来标识。URI 既是资源的名称，也是资源在 Web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互。</p><p><strong>资源的表述</strong></p><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><p><strong>状态转移</strong></p><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><p>Restful 是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用 <strong>“<u>url+请求方式</u>”</strong> 表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><ul><li><p>GET：用于获取资源</p></li><li><p>POST：用于新建资源</p></li><li><p>PUT：用于更新资源</p></li><li><p>DELETE：用于删除资源 </p></li></ul><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td><code>getUserById?id=1</code></td><td><code>user/1</code> get请求方式</td></tr><tr><td>保存操作</td><td><code>saveUser</code></td><td><code>user</code> post请求方式</td></tr><tr><td>删除操作</td><td><code>deleteUser?id=1</code></td><td><code>user/1</code> elete请求方式</td></tr><tr><td>更新操作</td><td><code>updateUser</code></td><td><code>user</code> put请求方式</td></tr></tbody></table><p>上述 url 地址 <code>/user/1</code> 中的 1 就是要获得的请求参数，在 SpringMVC 中可以使用占位符进行参数绑定。地址 <code>/user/1</code> 可以写成 <code>/user/&#123;id&#125;</code>，占位符 {id} 对应的就是 1 的值。在业务方法中我们可以使用 <strong><u>@PathVariable</u></strong> 注解进行占位符的匹配获取工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span></span>&#123;<br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.GET)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getUserAll</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>  <br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user/&#123;id&#125;&quot; method = RequestMethod.GET)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">getUserById</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>  &#125;<br>  <br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.POST)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">insertUser</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>  <br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * PUT 和 DELETE 的条件</span><br><span class="hljs-comment">  * POST</span><br><span class="hljs-comment">  * _method</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.PUT)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(string username, string password)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>  <br>  <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot; method = RequestMethod.DELETE)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a><u>HiddenHttpMethodFilter</u></h2><p>由于浏览器只支持发送 get 和 post 方式的请求，那么该如何发送 put 和 delete 请求。</p><p>SpringMVC 提供了 <strong><u>HiddenHttpMethodFilter</u></strong> 帮助我们**<u>将 POST 请求转换为 DELETE 或 PUT 请求</u>**。</p><p><strong><u>HiddenHttpMethodFilter</u></strong> 处理put和delete请求的条件：</p><ul><li><p>当前请求的请求方式必须为 post；</p></li><li><p>当前请求必须传输请求参数 _method。</p></li></ul><p>注册 <strong>HiddenHttpMethodFilter</strong> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- web.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意！必须先注册 **<u>CharacterEncodingFilter</u>**，再注册 <u><strong>HiddenHttpMethodFilter</strong></u>。</p><p>原因</p><ul><li><p>在 <strong><u>CharacterEncodingFilter</u></strong> 中通过 <code>request.setCharacterEncoding(encoding)</code> 方法设置字符集的；</p></li><li><p><code>request.setCharacterEncoding(encoding)</code> 方法要求前面不能有任何获取请求参数的操作；</p></li><li><p>而 <u><strong>HiddenHttpMethodFilter</strong></u> 恰恰有一个获取请求方式的操作 <code>String paramValue = request.getParameter(this.methodParam);</code>。</p></li></ul></blockquote><h2 id="PathVariable注解"><a href="#PathVariable注解" class="headerlink" title="@PathVariable注解"></a>@PathVariable注解</h2><p> <span id = "@PathVariable注解"></span></p><p>@PathVariable 可以用来映射 URL 中的占位符到目标方法的参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;testPathVariable:&quot;</span>+id);<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h1><h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a><u>HttpMessageConverter</u></h2><p>**<u>HttpMessageConverter</u>**，报文信息转换器，将请求报文转换为 Java 对象，或将 Java 对象转换为响应报文。</p><p><u>HttpMessageConverter</u> 提供了两个注解和两个类型。</p><p>@RequestBody，@ResponseBody，RequestEntity，ResponseEntity。</p><h2 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="@RequestBody注解"></a>@RequestBody注解</h2><p> <span id = "@RequestBody注解"></span></p><p>@RequestBody 可以获取<strong>请求体</strong>，需要在 Controller 方法设置一个形参，使用 @RequestBody 进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestBody&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String requestBody)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;requestBody:&quot;</span>+requestBody);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// requestBody:username=admin&amp;password=123456</span><br></code></pre></td></tr></table></figure><h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><p>RequestEntity 是封装<strong>请求报文</strong>的一种类型，需要在 Controller 方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过 <code>getHeaders()</code> 获取请求头信息，通过 <code>getBody()</code> 获取请求体信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestEntity</span><span class="hljs-params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());<br>    System.out.println(<span class="hljs-string">&quot;requestBody:&quot;</span>+requestEntity.getBody());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="@ResponseBody注解"></a>@ResponseBody注解</h2><p> <span id = "@ResponseBody注解"></span></p><p>@ResponseBody 用于标识一个 Controller 方法，可以将该方法的返回值直接作为<strong>响应报文</strong>的响应体响应到浏览器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseBody&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testResponseBody</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="响应Json数据"><a href="#响应Json数据" class="headerlink" title="响应Json数据"></a>响应Json数据</h2><p>当 Java 对象作为返回值进行响应，会出现 HttpMessageNotWritableException 异常。需要将数据转化成 json 格式返回。</p><blockquote><ul><li><p>导入 <strong><u>jackson</u></strong> 依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>开启 mvc 注解驱动；</p><p>（在 <strong><u>HandlerAdaptor</u></strong> 中会自动装配一个消息转换器：**<u>MappingJackson2HttpMessageConverter</u>**，可以将响应到浏览器的 Java 对象转换为 json 格式的字符串）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 Controller 方法上使用 @ResponseBody 注解进行标识；</p></li><li><p>将 Java 对象直接作为 Controller 方法返回，自动转换为 json 格式字符串。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseUser&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">testResponseUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 浏览器的页面中展示的结果</span><br><span class="hljs-comment">// &#123;&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h2><p> <span id = "@RestController注解"></span></p><p>@RestController 注解是 SpringMVC 提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller 注解，并且为其中的每个方法添加了@ResponseBody 注解。</p><h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><p>ResponseEntity 用于 Controller 方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文。</p><p>（用于实现文件下载）</p><h1 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>使用 ResponseEntity 实现下载文件的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testDown&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 获取 ServletContext 对象</span><br>    ServletContext servletContext = session.getServletContext();<br>    <span class="hljs-comment">// 获取服务器中文件的真实路径</span><br>    String realPath = servletContext.getRealPath(<span class="hljs-string">&quot;/static/img/1.jpg&quot;</span>);<br>    <span class="hljs-comment">// 创建输入流</span><br>    InputStream is = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>    <span class="hljs-comment">// 创建字节数组</span><br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[is.available()];<br>    <span class="hljs-comment">// 将流读到字节数组中</span><br>    is.read(bytes);<br>    <span class="hljs-comment">// 创建HttpHeaders对象设置响应头信息</span><br>    MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> HttpHeaders();<br>    <span class="hljs-comment">// 设置要下载方式以及下载文件的名字</span><br>    headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=1.jpg&quot;</span>);<br>    <span class="hljs-comment">// 设置响应状态码</span><br>    HttpStatus statusCode = HttpStatus.OK;<br>    <span class="hljs-comment">// 创建 ResponseEntity 对象</span><br>    ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; responseEntity = <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);<br>    <span class="hljs-comment">// 关闭输入流</span><br>    is.close();<br>    <span class="hljs-keyword">return</span> responseEntity;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传要求 form 表单的请求方式必须为 <strong>post</strong>，并且添加属性 <code>enctype=&quot;multipart/form-data&quot;</code> ，SpringMVC 中将上传的文件封装到 <strong><u>MultipartFile</u></strong> 对象中，通过此对象可以获取文件相关信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- thymeleay视图解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testUp&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>  头像：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;photo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><p>导入 <strong><u>commons-fileupload</u></strong> 依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 SpringMVC 的配置文件中添加配置；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 必须通过文件解析器的解析才能将文件转换为MultipartFile对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Controller 方法（接受形参名与提交的名一致）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testUp&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testUp</span><span class="hljs-params">(MultipartFile photo, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 获取上传的文件的文件名</span><br>    String fileName = photo.getOriginalFilename();<br>    <span class="hljs-comment">// 处理文件重名问题</span><br>  <span class="hljs-comment">// 获取上传文件后缀名</span><br>    String hzName = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>    fileName = UUID.randomUUID().toString() + hzName;<br>    <span class="hljs-comment">// 获取服务器中photo目录的路径</span><br>    ServletContext servletContext = session.getServletContext();<br>    String photoPath = servletContext.getRealPath(<span class="hljs-string">&quot;photo&quot;</span>);<br>    File file = <span class="hljs-keyword">new</span> File(photoPath);<br>    <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>        file.mkdir();<br>    &#125;<br>    String finalPath = photoPath + File.separator + fileName;<br>    <span class="hljs-comment">// 实现上传功能</span><br>    photo.transferTo(<span class="hljs-keyword">new</span> File(finalPath));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h1 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h1><p><span id="SpringMVC的拦截器"></span></p><p>SpringMVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行 <strong>预处理（preHandler）</strong> 和<strong>后处理（postHandler）</strong>。</p><p>将拦截器按一定的顺序联结成一条链，这条链称为<strong>拦截器链（Interceptor Chain）</strong>。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是 AOP 思想的具体实现。</p><p><strong>拦截器与过略器的区别</strong></p><table><thead><tr><th><strong>区别</strong></th><th><strong>过滤器</strong></th><th><strong>拦截器</strong></th></tr></thead><tbody><tr><td>使用范围</td><td>是 servlet 规范中的一部分，任何 Java Web 工程都可以使用</td><td>是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用</td></tr><tr><td>拦截范围</td><td>在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截</td><td>只会拦截访问的控制器方法，如果访问的是 jsp、html、css、image、js 是不会进行拦截的</td></tr></tbody></table><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-09-18%2015.53.35.png" style="zoom:50%;" /><p><em><strong>即对 DispatchServlet 所处理的所有请求进行拦截。</strong></em></p><p><strong>配置使用拦截器。</strong></p><ul><li>创建拦截器类实现 <code>HandlerInterceptor</code> 接口<ul><li><code>preHandle</code><ul><li>目标方法执行前执行；</li></ul></li><li><code>postHandle</code><ul><li>目标方法执行后，视图返回前返回前执行；</li></ul></li><li><code>afterCompletion</code><ul><li>整个流程执行后执行。</li></ul></li></ul></li></ul><p><strong><u>HandlerInterceptor</u></strong></p><p>SpringMVC 中的拦截器用于拦截控制器方法的执行，SpringMVC 中的拦截器需要实现 **<u>HandlerInterceptor</u>**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>  <span class="hljs-comment">// 返回 true：放行 </span><br>  <span class="hljs-comment">// 返回 false：拦截</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse </span></span><br><span class="hljs-params"><span class="hljs-function">        response, Object handler)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;preHandle running...&quot;</span>);<br>    String param = request.getParametr(<span class="hljs-string">&quot;param&quot;</span>);<br>    <span class="hljs-keyword">if</span>(parma.equals(<span class="hljs-string">&quot;yes&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      request.getRequestDisaptcher(<span class="hljs-string">&quot;/error.jsp&quot;</span>).forward(request, response);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>  &#125;<br>  <span class="hljs-comment">// 可以在此方法修改视图 modelAndView</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse </span></span><br><span class="hljs-params"><span class="hljs-function">        response, Object handler, ModelAndView modelAndView)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;postHandle running...&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse </span></span><br><span class="hljs-params"><span class="hljs-function">        response, Object handler, Exception ex)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;afterCompletion running...&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置注册拦截器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springMVC.xml --&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用bean --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testRequestEntity&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tsuiraku.interceptor.MyHandlerInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用ref --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testRequestEntity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;MyHandlerInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <em><strong>&lt;bean&gt;</strong></em> 配置拦截器，此时所有的请求都会经过 <em><strong>MyHandlerInterceptor</strong></em> 拦截器。</p><p>使用 <em><strong>&lt;ref&gt;</strong></em> 配置拦截器，此时所有的请求都会经过 <em><strong>MyHandlerInterceptor</strong></em> 拦截器。</p><p>当只使用以上两种方式之一，此时会对所有请求路径进行拦截。</p><p>当使用 *<strong>&lt;mvc:mapping*&gt;</strong> ，指定需要拦截的请求路径。</p><p>当使用 ***&lt;mvc:exclude-mapping&gt;***，指定放行的请求路径。</p><p><strong>拦截器的三个方法。</strong></p><table><thead><tr><th align="center"><strong>方法名</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>preHandle()</strong></td><td align="left">方法将在请求处理之前进行调用，该方法的返回值是布尔值 Boolean 类型的。当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时就会继续调用下一个Interceptor 的 preHandle 方法。</td></tr><tr><td align="center"><strong>postHandle()</strong></td><td align="left">该方法是在当前请求进行处理之后被调用，前提是 preHandle 方法的返回值为true 时才能被调用，且它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作。</td></tr><tr><td align="center"><strong>afterCompletion()</strong></td><td align="left">该方法将在整个请求结束之后，也就是在 DispatcherServlet 渲染了对应的视图之后执行，前提是 preHandle 方法的返回值为true 时才能被调用。</td></tr></tbody></table><p><em><strong>当有多个拦截器时，执行顺序。</strong></em></p><ul><li><strong>preHandler</strong> 按照顺序执行；</li><li> <em><strong>postHandler</strong></em> 和 <em><strong>afterCompletion</strong></em> 按照反序执行。</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">O<span class="hljs-function"><span class="hljs-title">neHandlerInterceptor</span> -&gt;</span> preHandler<br>T<span class="hljs-function"><span class="hljs-title">woHandlerInterceptor</span> -&gt;</span> preHandler<br>T<span class="hljs-function"><span class="hljs-title">woHandlerInterceptor</span> -&gt;</span> postHandler<br>O<span class="hljs-function"><span class="hljs-title">neHandlerInterceptor</span> -&gt;</span> postHandler<br>T<span class="hljs-function"><span class="hljs-title">woHandlerInterceptor</span> -&gt;</span> afterCompletion<br>O<span class="hljs-function"><span class="hljs-title">neHandlerInterceptor</span> -&gt;</span> afterCompletion<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的异常处理器"><a href="#SpringMVC的异常处理器" class="headerlink" title="SpringMVC的异常处理器"></a>SpringMVC的异常处理器</h1><p><span id="SpringMVC的异常处理器"></span></p><p><strong><u>HandlerExceptionResolver</u></strong></p><p>系统中异常包括两类：<strong>预期异常</strong>和<strong>运行时异常（RuntimeException）</strong>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的 <strong>Dao</strong>、<strong>Service</strong>、<strong>Controller</strong> 出现都通过 throws Exception 向上抛出，最后由 SpringMVC 前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/image-20210821171506546.png"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p><strong>自定义异常处理的方式</strong></p><ul><li><p>使用 Spring MVC 提供的简单异常处理器 <strong><u>SimpleMappingExceptionResolver</u></strong></p></li><li><p>实现 Spring 的异常处理接口 <strong><u>HandlerExceptionResolver</u></strong> 自定义自己的异常处理器</p></li></ul><h2 id="基于配置的异常处理"><a href="#基于配置的异常处理" class="headerlink" title="基于配置的异常处理"></a><strong>基于配置的异常处理</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        properties的键表示处理器方法执行过程中出现的异常</span><br><span class="hljs-comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span><br><span class="hljs-comment">        --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionAttribute&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基于注解的异常处理"><a href="#基于注解的异常处理" class="headerlink" title="基于注解的异常处理"></a><strong>基于注解的异常处理</strong></h2><h3 id="ControllerAdvice注解"><a href="#ControllerAdvice注解" class="headerlink" title="@ControllerAdvice注解"></a>@ControllerAdvice注解</h3><p> <span id = "@ControllerAdvice注解"></span></p><p>增强的 Controller 注解。</p><blockquote><ol><li>全局异常处理；</li><li>全局数据绑定；</li><li>全局数据预处理。</li></ol></blockquote><h3 id="ExceptionHandler注解"><a href="#ExceptionHandler注解" class="headerlink" title="@ExceptionHandler注解"></a>@ExceptionHandler注解</h3><p> <span id = "@ExceptionHandler注解"></span></p><p>统一处理某一类异常，从而能够减少代码重复率和复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将当前类标识为异常处理的组件</span><br><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionController</span> </span>&#123;<br><br>    <span class="hljs-comment">// 用于设置所标识方法处理的异常</span><br>    <span class="hljs-meta">@ExceptionHandler(ArithmeticException.class)</span><br>    <span class="hljs-comment">// ex表示当前请求处理中出现的异常对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handleArithmeticException</span><span class="hljs-params">(Exception ex, Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基于注解配置SpringMVC"><a href="#基于注解配置SpringMVC" class="headerlink" title="基于注解配置SpringMVC"></a>基于注解配置SpringMVC</h1><p><em><strong>使用配置类和注解代替 web.xml 和 SpringMVC 配置文件的功能</strong></em></p><h2 id="WebInit"><a href="#WebInit" class="headerlink" title="WebInit"></a>WebInit</h2><p><strong><u>AbstractAnnotationConfigDispatcherServletInitializer</u></strong></p><p>在Servlet3.0 环境中，容器会在类路径中查找实现 <em><strong>javax.servlet.ServletContainerInitializer</strong></em> 接口的类，如果能够找到就使用它来配置 Servlet 容器。</p><p>Spring 提供了这个接口的实现，名为 <em><strong>SpringServletContainerInitializer</strong></em>，这个类反过来又会查找实现<em><strong>WebApplicationInitializer</strong></em> 的类并将配置的任务交给它来完成。Spring3.2 引入了一个便利的<em><strong>WebApplicationInitializer</strong></em> 基础实现，即 <em><strong>AbstractAnnotationConfigDispatcherServletInitializer</strong></em>。</p><p>当我们的类扩展了 <em><strong>AbstractAnnotationConfigDispatcherServletInitializer</strong></em> 并将其部署到 Servlet3.0 容器的时候，容器会自动发现它，并用它来配置 Servlet 上下文。</p><p>初始化类 <em><strong>WebInit</strong></em>，代替 <em><strong>web.xml</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定spring的配置类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;SpringConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定SpringMVC的配置类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;WebConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加过滤器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;<br>      <span class="hljs-comment">// 设置字符串过略器</span><br>        CharacterEncodingFilter encodingFilter = <span class="hljs-keyword">new</span> CharacterEncodingFilter();<br>        encodingFilter.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        encodingFilter.setForceRequestEncoding(<span class="hljs-keyword">true</span>);<br>      <span class="hljs-comment">// 设置HiddenHttpMethodFilter</span><br>        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WebConfig"><a href="#WebConfig" class="headerlink" title="WebConfig"></a>WebConfig</h2><p><strong><u>WebMvcConfigurer</u></strong></p><p>初始化类 <em><strong>WebConfig</strong></em>，代替 <em><strong>springMVC.xml</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 代替springMVC.xml</span><br><span class="hljs-comment">* 1. 扫描组件</span><br><span class="hljs-comment">* 2. 视图解析器</span><br><span class="hljs-comment">* 3. view-controller</span><br><span class="hljs-comment">* 4. default-servlet-handler</span><br><span class="hljs-comment">* 5. mvc注解驱动</span><br><span class="hljs-comment">* 6. 文件解析器</span><br><span class="hljs-comment">* 7. 异常处理</span><br><span class="hljs-comment">* 8. 拦截器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@ComponentScan(&quot;com.tsuiraku&quot;)</span> <span class="hljs-comment">// 扫描组件</span><br><span class="hljs-meta">@EnableWebMvc</span> <span class="hljs-comment">// 开启MVC注解驱动</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 使用default-servlet-handler处理静态资源</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span></span>&#123;<br>        configurer.enable(); <span class="hljs-comment">// 开启默认default-servlet-handler</span><br>    &#125;<br>  <br>  <span class="hljs-comment">// 配置view-controller</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewController</span><span class="hljs-params">(ViewControllerRegistry registry)</span></span>&#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/hello&quot;</span>).setViewName(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 配置文件上传解析器</span><br>  <span class="hljs-comment">// （导入依赖）</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonsMultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonsMultipartResolver();<br>    &#125;<br><br>    <span class="hljs-comment">// 配置拦截器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        FirstInterceptor firstInterceptor = <span class="hljs-keyword">new</span> FirstInterceptor();<br>        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置视图控制</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;<br>        registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 配置异常处理器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span></span><br><span class="hljs-function">    </span>&#123;<br>        SimpleMappingExceptionResolver exceptionResolver = <span class="hljs-keyword">new</span><br>          SimpleMappingExceptionResolver();<br>        Properties prop = <span class="hljs-keyword">new</span> Properties();<br>        prop.setProperty(<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>        <span class="hljs-comment">// 设置异常映射</span><br>        exceptionResolver.setExceptionMappings(prop);<br>        <span class="hljs-comment">// 设置共享异常信息的键</span><br>        exceptionResolver.setExceptionAttribute(<span class="hljs-string">&quot;ex&quot;</span>);<br>        resolvers.add(exceptionResolver);<br>    &#125;<br><br>  <span class="hljs-comment">// thymeleaf</span><br>    <span class="hljs-comment">// 配置生成模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITemplateResolver <span class="hljs-title">templateResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        WebApplicationContext webApplicationContext = <br>          ContextLoader.getCurrentWebApplicationContext();<br>        <span class="hljs-comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数</span><br>      <span class="hljs-comment">// 可通过WebApplicationContext 的方法获得</span><br>        ServletContextTemplateResolver templateResolver = <span class="hljs-keyword">new</span> <br>          ServletContextTemplateResolver(webApplicationContext.getServletContext());<br>        templateResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>);<br>        templateResolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);<br>        templateResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        templateResolver.setTemplateMode(TemplateMode.HTML);<br>        <span class="hljs-keyword">return</span> templateResolver;<br>    &#125;<br><br>  <span class="hljs-comment">// thymeleaf</span><br>    <span class="hljs-comment">// 生成模板引擎并为模板引擎注入模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title">templateEngine</span><span class="hljs-params">(ITemplateResolver templateResolver)</span> </span>&#123;<br>        SpringTemplateEngine templateEngine = <span class="hljs-keyword">new</span> SpringTemplateEngine();<br>        templateEngine.setTemplateResolver(templateResolver);<br>        <span class="hljs-keyword">return</span> templateEngine;<br>    &#125;<br>  <br><span class="hljs-comment">// thyleaf</span><br>    <span class="hljs-comment">// 生成视图解析器并未解析器注入模板引擎</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title">viewResolver</span><span class="hljs-params">(SpringTemplateEngine templateEngine)</span> </span>&#123;<br>        ThymeleafViewResolver viewResolver = <span class="hljs-keyword">new</span> ThymeleafViewResolver();<br>        viewResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        viewResolver.setTemplateEngine(templateEngine);<br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringConfig"><a href="#SpringConfig" class="headerlink" title="SpringConfig"></a>SpringConfig</h2><p>初始化类 <em><strong>SpringConfig</strong></em>，代替 <em><strong>spring.xml</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br><span class="hljs-comment">// ssm整合之后，spring的配置信息写在此类中</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringMVC的组件解析"><a href="#SpringMVC的组件解析" class="headerlink" title="SpringMVC的组件解析"></a>SpringMVC的组件解析</h1><h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><blockquote><ol><li><p><strong>前端控制器：DispatcherServlet</strong></p><p>用户请求到达前端控制器，它就相当于 <em><strong>MVC</strong></em> 模式中的 <em><strong>C</strong></em>，<em><strong>DispatcherServlet</strong></em> 是整个流程控制的中心，由，它调用其它组件处理用户的请求，<em><strong>DispatcherServlet</strong></em> 的存在降低了组件之间的耦合性。</p><p>统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求。</p></li><li><p><strong>处理器映射器：HandlerMapping</strong></p><p><em><strong>HandlerMapping</strong></em> 负责根据用户请求找到 <em><strong>Handler</strong></em> 即处理器 Controller，SpringMVC 提供了不同的映射器实现不同的。映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p>根据请求的 <em><strong>url、method</strong></em> 等信息查找 <em><strong>Handler</strong></em>，即控制器方法。</p></li><li><p><strong>处理器适配器：HandlerAdapter</strong></p><p>通过 <em><strong>HandlerAdapter</strong></em> 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理。</p></li><li><p><strong>处理器：Handler</strong></p><p>在 <em><strong>DispatcherServlet</strong></em> 的控制下 <em><strong>Handler</strong></em> 对具体的用户请求进行处理。</p><p>它就是我们开发中要编写的具体业务控制器。由 <em><strong>DispatcherServlet</strong></em> 把用户请求转发到 <em><strong>Handler</strong></em>。由</p><p><em><strong>Handler</strong></em> 对具体的用户请求进行处理。</p><p>即控制器 <em><strong>Controller</strong></em>。</p></li><li><p><strong>视图解析器：View Resolver</strong></p><p><em><strong>View Resolver</strong></em> 负责将处理结果生成 <em><strong>View</strong></em> 视图，<em><strong>View Resolver</strong></em> 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 <em><strong>View</strong></em> 视图对象，最后对 <em><strong>View</strong></em> 进行渲染将处理结果通过页面展示给用户。（<em><strong>ThymeleafView、InternalResourceView、RedirectView</strong></em>）</p><p>即进行视图解析，得到相应的视图。</p></li><li><p><strong>视图：View</strong></p><p><em><strong>SpringMVC</strong></em> 框架提供了很多的 <em><strong>View</strong></em> 视图类型的支持，包括：<em><strong>jstlView、freemarkerView、pdfView</strong></em> 等。最常用的视图就是 <em><strong>jsp</strong></em>。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p><p>即将模型数据通过页面展示给用户。</p></li></ol></blockquote><h2 id="DispatchServlet"><a href="#DispatchServlet" class="headerlink" title="DispatchServlet"></a>DispatchServlet</h2><p><em><strong>：中央控制器</strong></em></p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/img005.png"  style="zoom:70%;" /><h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><p><em><strong><u>源码 to do</u></strong></em></p><h3 id="服务过程"><a href="#服务过程" class="headerlink" title="服务过程"></a>服务过程</h3><p><em><strong><u>源码 to do</u></strong></em></p><h3 id="调用组件处理请求"><a href="#调用组件处理请求" class="headerlink" title="调用组件处理请求"></a>调用组件处理请求</h3><p><em><strong><u>源码 to do</u></strong></em></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><img src="https://gitee.com/tsuiraku/typora/raw/master/img/%E6%88%AA%E5%B1%8F2021-09-19%2010.23.18.png" style="zoom:50%;" /><p><strong><u>总结流程</u></strong></p><blockquote><ol><li><p>用户向服务器发送请求，请求被前端控制器 <em><strong>DispatcherServlet</strong></em> 捕获；</p></li><li><p><em><strong>DispatcherServlet</strong></em> 收到请求，对请求 <em><strong>URL</strong></em> 进行解析，得到请求资源标志符（<em><strong>URL</strong></em>）， 调用 <em><strong>HandlerMapping</strong></em> 处理器映射器；</p><ol><li><p>若当前映射不存在（<em><strong>HandlerMapping</strong></em>）；</p><ol><li><p>判断是否配置默认 <em><strong>Servlet</strong></em> 处理资源资源： ***&lt;default-servlet-handler&gt;***。</p></li><li><p>若未配置，控制台显示映射无法找到，客户端展示 <em><strong>404</strong></em> 页面错误；</p><img src="https://gitee.com/tsuiraku/typora/raw/master/img/img007.png" alt="img007" style="zoom:50%;" /></li><li><p>若已经配置，但是无法找到访问资源，客户端展示 <em><strong>404</strong></em> 页面错误。</p></li></ol></li><li><p>若当前映射存在。</p><ol><li><p>根据该 <em><strong>URI</strong></em>，调用 <em><strong>HandlerMapping</strong></em> 获得该 <em><strong>Handler</strong></em> 配置的所有相关的对象（包括 <em><strong>Handler</strong></em> 对象以及 <em><strong>Handler</strong></em> 对象对应的拦截器），最后以 <em><strong>HandlerExecutionChain</strong></em> 执行链对象的形式返回；</p></li><li><p><em><strong>DispatcherServlet</strong></em> 根据获得的 <em><strong>Handler</strong></em>，选择一个合适的 <em><strong>HandlerAdapter</strong></em>；</p></li><li><p>如果成功获得 <em><strong>HandlerAdapter</strong></em>，此时将开始执行拦截器的 <em><strong>preHandler</strong></em>方法；</p></li><li><p>提取 <em><strong>Request</strong></em> 中的模型数据，填充 <em><strong>Handler</strong></em> 入参，开始执行 <em><strong>Handler</strong></em> 方法，即 <em><strong>Controller</strong></em> 方法，处理请求。在填充 <em><strong>Handler</strong></em> 的入参过程中，根据你的配置，<em><strong>Spring</strong></em> 将帮你做一些额外的工作：</p><ol><li><p><em><strong>HttpMessageConveter</strong></em></p><p>将请求消息（如 <em><strong>Json、xml</strong></em> 等数据）转换成一个对象，将对象转换为指定的响应信息。</p></li><li><p>数据转换</p><p>对请求消息进行数据转换。</p></li><li><p>数据格式化</p><p>对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p></li><li><p>数据验证</p><p>验证数据的有效性（长度、格式等）。</p></li></ol></li><li><p><em><strong>Handler</strong></em> 执行完成后，向 <em><strong>DispatcherServlet</strong></em> 返回一个 <em><strong>ModelAndView</strong></em> 对象；</p></li><li><p>此时将开始执行拦截器的 <em><strong>postHandle</strong></em> 方法；</p></li><li><p>根据返回的 <em><strong>ModelAndView</strong></em> </p><ol><li><p>若存在异常，则执行 <em><strong>HandlerExceptionResolver</strong></em> 进行异常处理；</p></li><li><p>否则，选择一个适合的 <em><strong>ViewResolver</strong></em> 进行视图解析，根据 <em><strong>Model</strong></em> 和 <em><strong>View</strong></em>，来渲染视图。</p></li></ol></li><li><p>渲染视图完毕执行拦截器的 <em><strong>afterCompletion</strong></em> 方法；</p></li><li><p>将渲染结果返回给客户端。</p></li></ol></li></ol></li></ol></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><ul><li><a href="https://www.bilibili.com/video/BV1Ry4y1574R?p=1">尚硅谷-杨博超</a></li><li><a href="https://www.bilibili.com/video/BV1WZ4y1P7Bp?spm_id_from=333.999.0.0">黑马程序员</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>Spring家族</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springmvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常</title>
    <link href="/2020/10/10/java-exception/"/>
    <url>/2020/10/10/java-exception/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>异常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/10/10/computer-network/"/>
    <url>/2020/10/10/computer-network/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>编程基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2020/10/10/java-collection/"/>
    <url>/2020/10/10/java-collection/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机</title>
    <link href="/2020/10/10/java-jvm/"/>
    <url>/2020/10/10/java-jvm/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java反射</title>
    <link href="/2020/10/10/java-reflection/"/>
    <url>/2020/10/10/java-reflection/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>语言基础</category>
      
      <category>反射</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2020/10/10/java-socket/"/>
    <url>/2020/10/10/java-socket/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java语言</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2020/10/10/os/"/>
    <url>/2020/10/10/os/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>编程基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2020/10/10/spring/"/>
    <url>/2020/10/10/spring/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>Spring家族</category>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2020/10/10/springboot/"/>
    <url>/2020/10/10/springboot/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>应用框架</category>
      
      <category>后端</category>
      
      <category>Spring家族</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
